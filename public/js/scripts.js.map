{"version":3,"sources":["leaflet.awesome-markers.js","angular-simple-logger.js","angular-leaflet-directive.js","angucomplete-alt.js","app.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/mBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACp2KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1zBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"scripts.js","sourcesContent":["/*\n  Leaflet.AwesomeMarkers, a plugin that adds colorful iconic markers for Leaflet, based on the Font Awesome icons\n  (c) 2012-2013, Lennard Voogdt\n\n  http://leafletjs.com\n  https://github.com/lvoogdt\n*/\n\n/*global L*/\n\n(function (window, document, undefined) {\n    \"use strict\";\n    /*\n     * Leaflet.AwesomeMarkers assumes that you have already included the Leaflet library.\n     */\n\n    L.AwesomeMarkers = {};\n\n    L.AwesomeMarkers.version = '2.0.1';\n\n    L.AwesomeMarkers.Icon = L.Icon.extend({\n        options: {\n            iconSize: [35, 45],\n            iconAnchor:   [17, 42],\n            popupAnchor: [1, -32],\n            shadowAnchor: [10, 12],\n            shadowSize: [36, 16],\n            className: 'awesome-marker',\n            prefix: 'glyphicon',\n            spinClass: 'fa-spin',\n            extraClasses: '',\n            icon: 'home',\n            markerColor: 'blue',\n            iconColor: 'white'\n        },\n\n        initialize: function (options) {\n            options = L.Util.setOptions(this, options);\n        },\n\n        createIcon: function () {\n            var div = document.createElement('div'),\n                options = this.options;\n\n            if (options.icon) {\n                div.innerHTML = this._createInner();\n            }\n\n            if (options.bgPos) {\n                div.style.backgroundPosition =\n                    (-options.bgPos.x) + 'px ' + (-options.bgPos.y) + 'px';\n            }\n\n            this._setIconStyles(div, 'icon-' + options.markerColor);\n            return div;\n        },\n\n        _createInner: function() {\n            var iconClass, iconSpinClass = \"\", iconColorClass = \"\", iconColorStyle = \"\", options = this.options;\n\n            if(options.icon.slice(0,options.prefix.length+1) === options.prefix + \"-\") {\n                iconClass = options.icon;\n            } else {\n                iconClass = options.prefix + \"-\" + options.icon;\n            }\n\n            if(options.spin && typeof options.spinClass === \"string\") {\n                iconSpinClass = options.spinClass;\n            }\n\n            if(options.iconColor) {\n                if(options.iconColor === 'white' || options.iconColor === 'black') {\n                    iconColorClass = \"icon-\" + options.iconColor;\n                } else {\n                    iconColorStyle = \"style='color: \" + options.iconColor + \"' \";\n                }\n            }\n\n            return \"<i \" + iconColorStyle + \"class='\" + options.extraClasses + \" \" + options.prefix + \" \" + iconClass + \" \" + iconSpinClass + \" \" + iconColorClass + \"'></i>\";\n        },\n\n        _setIconStyles: function (img, name) {\n            var options = this.options,\n                size = L.point(options[name === 'shadow' ? 'shadowSize' : 'iconSize']),\n                anchor;\n\n            if (name === 'shadow') {\n                anchor = L.point(options.shadowAnchor || options.iconAnchor);\n            } else {\n                anchor = L.point(options.iconAnchor);\n            }\n\n            if (!anchor && size) {\n                anchor = size.divideBy(2, true);\n            }\n\n            img.className = 'awesome-marker-' + name + ' ' + options.className;\n\n            if (anchor) {\n                img.style.marginLeft = (-anchor.x) + 'px';\n                img.style.marginTop  = (-anchor.y) + 'px';\n            }\n\n            if (size) {\n                img.style.width  = size.x + 'px';\n                img.style.height = size.y + 'px';\n            }\n        },\n\n        createShadow: function () {\n            var div = document.createElement('div');\n\n            this._setIconStyles(div, 'shadow');\n            return div;\n      }\n    });\n        \n    L.AwesomeMarkers.icon = function (options) {\n        return new L.AwesomeMarkers.Icon(options);\n    };\n\n}(this, document));\n\n\n\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nangular.module('nemLogging', []);\n\nangular.module('nemLogging').provider('nemDebug', function (){\n  var ourDebug = null;\n  ourDebug = require('debug');\n\n  this.$get =  function(){\n    //avail as service\n    return ourDebug;\n  };\n\n  //avail at provider, config time\n  this.debug = ourDebug;\n\n  return this;\n});\nvar bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\nangular.module('nemLogging').provider('nemSimpleLogger', [\n  'nemDebugProvider', function(nemDebugProvider) {\n    var LEVELS, Logger, _fns, _isValidLogObject, _maybeExecLevel, _wrapDebug, key, nemDebug, val;\n    nemDebug = nemDebugProvider.debug;\n    _fns = ['debug', 'info', 'warn', 'error', 'log'];\n    LEVELS = {};\n    for (key in _fns) {\n      val = _fns[key];\n      LEVELS[val] = key;\n    }\n    _maybeExecLevel = function(level, current, fn) {\n      if (level >= current) {\n        return fn();\n      }\n    };\n    _isValidLogObject = function(logObject) {\n      var isValid;\n      isValid = false;\n      if (!logObject) {\n        return isValid;\n      }\n      for (key in _fns) {\n        val = _fns[key];\n        isValid = (logObject[val] != null) && typeof logObject[val] === 'function';\n        if (!isValid) {\n          break;\n        }\n      }\n      return isValid;\n    };\n\n    /*\n      Overide logeObject.debug with a nemDebug instance\n      see: https://github.com/visionmedia/debug/blob/master/Readme.md\n     */\n    _wrapDebug = function(debugStrLevel, logObject) {\n      var debugInstance, newLogger;\n      debugInstance = nemDebug(debugStrLevel);\n      newLogger = {};\n      for (key in _fns) {\n        val = _fns[key];\n        newLogger[val] = val === 'debug' ? debugInstance : logObject[val];\n      }\n      return newLogger;\n    };\n    Logger = (function() {\n      function Logger($log1) {\n        var logFns;\n        this.$log = $log1;\n        this.spawn = bind(this.spawn, this);\n        if (!this.$log) {\n          throw 'internalLogger undefined';\n        }\n        if (!_isValidLogObject(this.$log)) {\n          throw '@$log is invalid';\n        }\n        this.doLog = true;\n        logFns = {};\n        _fns.forEach((function(_this) {\n          return function(level) {\n            logFns[level] = function(msg) {\n              if (_this.doLog) {\n                return _maybeExecLevel(LEVELS[level], _this.currentLevel, function() {\n                  return _this.$log[level](msg);\n                });\n              }\n            };\n            return _this[level] = logFns[level];\n          };\n        })(this));\n        this.LEVELS = LEVELS;\n        this.currentLevel = LEVELS.error;\n      }\n\n      Logger.prototype.spawn = function(newInternalLogger) {\n        if (typeof newInternalLogger === 'string') {\n          if (!_isValidLogObject(this.$log)) {\n            throw '@$log is invalid';\n          }\n          if (!nemDebug) {\n            throw 'nemDebug is undefined this is probably the light version of this library sep debug logggers is not supported!';\n          }\n          return _wrapDebug(newInternalLogger, this.$log);\n        }\n        return new Logger(newInternalLogger || this.$log);\n      };\n\n      return Logger;\n\n    })();\n    this.decorator = [\n      '$log', function($delegate) {\n        var log;\n        log = new Logger($delegate);\n        log.currentLevel = LEVELS.debug;\n        return log;\n      }\n    ];\n    this.$get = [\n      '$log', function($log) {\n        return new Logger($log);\n      }\n    ];\n    return this;\n  }\n]);\n\n},{\"debug\":2}],2:[function(require,module,exports){\n\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  return ('WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  return JSON.stringify(v);\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs() {\n  var args = arguments;\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return args;\n\n  var c = 'color: ' + this.color;\n  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n  return args;\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage(){\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n},{\"./debug\":3}],3:[function(require,module,exports){\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = debug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lowercased letter, i.e. \"n\".\n */\n\nexports.formatters = {};\n\n/**\n * Previously assigned color.\n */\n\nvar prevColor = 0;\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n *\n * @return {Number}\n * @api private\n */\n\nfunction selectColor() {\n  return exports.colors[prevColor++ % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction debug(namespace) {\n\n  // define the `disabled` version\n  function disabled() {\n  }\n  disabled.enabled = false;\n\n  // define the `enabled` version\n  function enabled() {\n\n    var self = enabled;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // add the `color` if not set\n    if (null == self.useColors) self.useColors = exports.useColors();\n    if (null == self.color && self.useColors) self.color = selectColor();\n\n    var args = Array.prototype.slice.call(arguments);\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %o\n      args = ['%o'].concat(args);\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    if ('function' === typeof exports.formatArgs) {\n      args = exports.formatArgs.apply(self, args);\n    }\n    var logFn = enabled.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n  enabled.enabled = true;\n\n  var fn = exports.enabled(namespace) ? enabled : disabled;\n\n  fn.namespace = namespace;\n\n  return fn;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n},{\"ms\":4}],4:[function(require,module,exports){\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options){\n  options = options || {};\n  if ('string' == typeof val) return parse(val);\n  return options.long\n    ? long(val)\n    : short(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = '' + str;\n  if (str.length > 10000) return;\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n  if (!match) return;\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction short(ms) {\n  if (ms >= d) return Math.round(ms / d) + 'd';\n  if (ms >= h) return Math.round(ms / h) + 'h';\n  if (ms >= m) return Math.round(ms / m) + 'm';\n  if (ms >= s) return Math.round(ms / s) + 's';\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction long(ms) {\n  return plural(ms, d, 'day')\n    || plural(ms, h, 'hour')\n    || plural(ms, m, 'minute')\n    || plural(ms, s, 'second')\n    || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) return;\n  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n},{}]},{},[1]);\n","/**!\n * The MIT License\n *\n * Copyright (c) 2013 the angular-leaflet-directive Team, http://tombatossals.github.io/angular-leaflet-directive\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * angular-leaflet-directive\n * https://github.com/tombatossals/angular-leaflet-directive\n *\n * @authors https://github.com/tombatossals/angular-leaflet-directive/graphs/contributors\n */\n\n/*!\n*  angular-leaflet-directive  2015-11-06\n*  angular-leaflet-directive - An AngularJS directive to easily interact with Leaflet maps\n*  git: https://github.com/tombatossals/angular-leaflet-directive\n*/\n(function(angular){\n'use strict';\nangular.module(\"leaflet-directive\", []).directive('leaflet',\n    [\"$q\", \"leafletData\", \"leafletMapDefaults\", \"leafletHelpers\", \"leafletMapEvents\", function ($q, leafletData, leafletMapDefaults, leafletHelpers, leafletMapEvents) {\n    return {\n        restrict: \"EA\",\n        replace: true,\n        scope: {\n            center         : '=',\n            lfCenter       : '=',\n            defaults       : '=',\n            maxbounds      : '=',\n            bounds         : '=',\n            markers        : '=',\n            legend         : '=',\n            geojson        : '=',\n            paths          : '=',\n            tiles          : '=',\n            layers         : '=',\n            controls       : '=',\n            decorations    : '=',\n            eventBroadcast : '=',\n            markersWatchOptions : '=',\n            geojsonWatchOptions : '='\n        },\n        transclude: true,\n        template: '<div class=\"angular-leaflet-map\"><div ng-transclude></div></div>',\n        controller: [\"$scope\", function ($scope) {\n            this._leafletMap = $q.defer();\n            this.getMap = function () {\n                return this._leafletMap.promise;\n            };\n\n            this.getLeafletScope = function() {\n                return $scope;\n            };\n        }],\n\n        link: function(scope, element, attrs, ctrl) {\n            var isDefined = leafletHelpers.isDefined,\n                defaults  = leafletMapDefaults.setDefaults(scope.defaults, attrs.id),\n                mapEvents = leafletMapEvents.getAvailableMapEvents(),\n                addEvents = leafletMapEvents.addEvents;\n\n            scope.mapId =  attrs.id;\n            leafletData.setDirectiveControls({}, attrs.id);\n\n            // Set width and height utility functions\n            function updateWidth() {\n                if (isNaN(attrs.width)) {\n                    element.css('width', attrs.width);\n                } else {\n                    element.css('width', attrs.width + 'px');\n                }\n            }\n\n            function updateHeight() {\n                if (isNaN(attrs.height)) {\n                    element.css('height', attrs.height);\n                } else {\n                    element.css('height', attrs.height + 'px');\n                }\n            }\n\n            // If the width attribute defined update css\n            // Then watch if bound property changes and update css\n            if (isDefined(attrs.width)) {\n                updateWidth();\n\n                scope.$watch(\n                    function () {\n                        return element[0].getAttribute('width');\n                    },\n                    function () {\n                        updateWidth();\n                        map.invalidateSize();\n                    });\n            }\n\n            // If the height attribute defined update css\n            // Then watch if bound property changes and update css\n            if (isDefined(attrs.height)) {\n                updateHeight();\n\n                scope.$watch(\n                    function () {\n                        return element[0].getAttribute('height');\n                    },\n                    function () {\n                        updateHeight();\n                        map.invalidateSize();\n                    });\n            }\n\n            // Create the Leaflet Map Object with the options\n            var map = new L.Map(element[0], leafletMapDefaults.getMapCreationDefaults(attrs.id));\n            ctrl._leafletMap.resolve(map);\n\n            if (!isDefined(attrs.center) && !isDefined(attrs.lfCenter)) {\n                map.setView([defaults.center.lat, defaults.center.lng], defaults.center.zoom);\n            }\n\n            // If no layers nor tiles defined, set the default tileLayer\n            if (!isDefined(attrs.tiles) && (!isDefined(attrs.layers))) {\n                var tileLayerObj = L.tileLayer(defaults.tileLayer, defaults.tileLayerOptions);\n                tileLayerObj.addTo(map);\n                leafletData.setTiles(tileLayerObj, attrs.id);\n            }\n\n            // Set zoom control configuration\n            if (isDefined(map.zoomControl) &&\n                isDefined(defaults.zoomControlPosition)) {\n                map.zoomControl.setPosition(defaults.zoomControlPosition);\n            }\n\n            if (isDefined(map.zoomControl) &&\n                defaults.zoomControl===false) {\n                map.zoomControl.removeFrom(map);\n            }\n\n            if (isDefined(map.zoomsliderControl) &&\n                isDefined(defaults.zoomsliderControl) &&\n                defaults.zoomsliderControl===false) {\n                map.zoomsliderControl.removeFrom(map);\n            }\n\n\n            // if no event-broadcast attribute, all events are broadcasted\n            if (!isDefined(attrs.eventBroadcast)) {\n                var logic = \"broadcast\";\n                addEvents(map, mapEvents, \"eventName\", scope, logic);\n            }\n\n            // Resolve the map object to the promises\n            map.whenReady(function() {\n                leafletData.setMap(map, attrs.id);\n            });\n\n            scope.$on('$destroy', function () {\n                leafletMapDefaults.reset();\n                map.remove();\n                leafletData.unresolveMap(attrs.id);\n            });\n\n            //Handle request to invalidate the map size\n            //Up scope using $scope.$emit('invalidateSize')\n            //Down scope using $scope.$broadcast('invalidateSize')\n            scope.$on('invalidateSize', function() {\n                map.invalidateSize();\n            });\n        }\n    };\n}]);\n\nangular.module(\"leaflet-directive\").factory('leafletBoundsHelpers', [\"$log\", \"leafletHelpers\", function ($log, leafletHelpers) {\n\n    var isArray = leafletHelpers.isArray,\n        isNumber = leafletHelpers.isNumber,\n        isFunction = leafletHelpers.isFunction,\n        isDefined = leafletHelpers.isDefined;\n        \n    function _isValidBounds(bounds) {\n        return angular.isDefined(bounds) && angular.isDefined(bounds.southWest) &&\n               angular.isDefined(bounds.northEast) && angular.isNumber(bounds.southWest.lat) &&\n               angular.isNumber(bounds.southWest.lng) && angular.isNumber(bounds.northEast.lat) &&\n               angular.isNumber(bounds.northEast.lng);\n    }\n\n    return {\n        createLeafletBounds: function(bounds) {\n            if (_isValidBounds(bounds)) {\n                return L.latLngBounds([bounds.southWest.lat, bounds.southWest.lng],\n                                      [bounds.northEast.lat, bounds.northEast.lng ]);\n            }\n        },\n\n        isValidBounds: _isValidBounds,\n\n        createBoundsFromArray: function(boundsArray) {\n            if (!(isArray(boundsArray) && boundsArray.length === 2 &&\n                  isArray(boundsArray[0]) && isArray(boundsArray[1]) &&\n                  boundsArray[0].length === 2 && boundsArray[1].length === 2 &&\n                  isNumber(boundsArray[0][0]) && isNumber(boundsArray[0][1]) &&\n                  isNumber(boundsArray[1][0]) && isNumber(boundsArray[1][1]))) {\n                $log.error(\"[AngularJS - Leaflet] The bounds array is not valid.\");\n                return;\n            }\n\n            return {\n                northEast: {\n                    lat: boundsArray[0][0],\n                    lng: boundsArray[0][1]\n                },\n                southWest: {\n                    lat: boundsArray[1][0],\n                    lng: boundsArray[1][1]\n                }\n            };\n        },\n\n        createBoundsFromLeaflet: function(lfBounds) {\n            if (!(isDefined(lfBounds) && isFunction(lfBounds.getNorthEast) && isFunction(lfBounds.getSouthWest))) {\n                $log.error(\"[AngularJS - Leaflet] The leaflet bounds is not valid object.\");\n                return;\n            }\n\n            var northEast = lfBounds.getNorthEast(),\n                southWest = lfBounds.getSouthWest();\n\n            return {\n                northEast: {\n                    lat: northEast.lat,\n                    lng: northEast.lng\n                },\n                southWest: {\n                    lat: southWest.lat,\n                    lng: southWest.lng\n                }\n            };\n        }\n    };\n}]);\n\nangular.module(\"leaflet-directive\").factory('leafletControlHelpers', [\"$rootScope\", \"$log\", \"leafletHelpers\", \"leafletLayerHelpers\", \"leafletMapDefaults\", function ($rootScope, $log, leafletHelpers, leafletLayerHelpers, leafletMapDefaults) {\n    var isDefined = leafletHelpers.isDefined,\n        isObject = leafletHelpers.isObject,\n        createLayer = leafletLayerHelpers.createLayer,\n        _controls = {},\n        errorHeader = leafletHelpers.errorHeader + ' [Controls] ';\n\n    var _controlLayersMustBeVisible = function(baselayers, overlays, mapId) {\n        var defaults = leafletMapDefaults.getDefaults(mapId);\n        if(!defaults.controls.layers.visible) {\n            return false;\n        }\n\n        var atLeastOneControlItemMustBeShown = false;\n\n        if (isObject(baselayers)) {\n            Object.keys(baselayers).forEach(function(key) {\n                var layer = baselayers[key];\n                if (!isDefined(layer.layerOptions) || layer.layerOptions.showOnSelector !== false) {\n                    atLeastOneControlItemMustBeShown = true;\n                }\n            });\n        }\n\n        if (isObject(overlays)) {\n            Object.keys(overlays).forEach(function(key) {\n                var layer = overlays[key];\n                if (!isDefined(layer.layerParams) || layer.layerParams.showOnSelector !== false) {\n                    atLeastOneControlItemMustBeShown = true;\n                }\n            });\n        }\n\n        return atLeastOneControlItemMustBeShown;\n    };\n\n    var _createLayersControl = function(mapId) {\n        var defaults = leafletMapDefaults.getDefaults(mapId);\n        var controlOptions = {\n            collapsed: defaults.controls.layers.collapsed,\n            position: defaults.controls.layers.position,\n            autoZIndex: false\n        };\n\n        angular.extend(controlOptions, defaults.controls.layers.options);\n\n        var control;\n        if(defaults.controls.layers && isDefined(defaults.controls.layers.control)) {\n\t\t\tcontrol = defaults.controls.layers.control.apply(this, [[], [], controlOptions]);\n\t\t} else {\n\t\t\tcontrol = new L.control.layers([], [], controlOptions);\n\t\t}\n\n        return control;\n    };\n\n    var controlTypes = {\n        draw: {\n            isPluginLoaded: function() {\n                if (!angular.isDefined(L.Control.Draw)) {\n                    $log.error(errorHeader + ' Draw plugin is not loaded.');\n                    return false;\n                }\n                return true;\n            },\n            checkValidParams: function(/* params */) {\n                return true;\n            },\n            createControl: function(params) {\n                return new L.Control.Draw(params);\n            }\n        },\n        scale: {\n            isPluginLoaded: function() {\n                return true;\n            },\n            checkValidParams: function(/* params */) {\n                return true;\n            },\n            createControl: function(params) {\n                return new L.control.scale(params);\n            }\n        },\n        fullscreen: {\n            isPluginLoaded: function() {\n                if (!angular.isDefined(L.Control.Fullscreen)) {\n                    $log.error(errorHeader + ' Fullscreen plugin is not loaded.');\n                    return false;\n                }\n                return true;\n            },\n            checkValidParams: function(/* params */) {\n                return true;\n            },\n            createControl: function(params) {\n                return new L.Control.Fullscreen(params);\n            }\n        },\n        search: {\n            isPluginLoaded: function() {\n                if (!angular.isDefined(L.Control.Search)) {\n                    $log.error(errorHeader + ' Search plugin is not loaded.');\n                    return false;\n                }\n                return true;\n            },\n            checkValidParams: function(/* params */) {\n                return true;\n            },\n            createControl: function(params) {\n                return new L.Control.Search(params);\n            }\n        },\n        custom: {},\n        minimap: {\n            isPluginLoaded: function() {\n                if (!angular.isDefined(L.Control.MiniMap)) {\n                    $log.error(errorHeader + ' Minimap plugin is not loaded.');\n                    return false;\n                }\n\n                return true;\n            },\n            checkValidParams: function(params) {\n                if(!isDefined(params.layer)) {\n                    $log.warn(errorHeader +' minimap \"layer\" option should be defined.');\n                    return false;\n                }\n                return true;\n            },\n            createControl: function(params) {\n                var layer = createLayer(params.layer);\n\n                if (!isDefined(layer)) {\n                    $log.warn(errorHeader + ' minimap control \"layer\" could not be created.');\n                    return;\n                }\n\n                return new L.Control.MiniMap(layer, params);\n            }\n        }\n    };\n\n    return {\n        layersControlMustBeVisible: _controlLayersMustBeVisible,\n\n        isValidControlType: function(type) {\n            return Object.keys(controlTypes).indexOf(type) !== -1;\n        },\n\n        createControl: function (type, params) {\n            if (!controlTypes[type].checkValidParams(params)) {\n                return;\n            }\n\n            return controlTypes[type].createControl(params);\n        },\n\n        updateLayersControl: function(map, mapId, loaded, baselayers, overlays, leafletLayers) {\n            var i;\n            var _layersControl = _controls[mapId];\n            var mustBeLoaded = _controlLayersMustBeVisible(baselayers, overlays, mapId);\n\n            if (isDefined(_layersControl) && loaded) {\n                for (i in leafletLayers.baselayers) {\n                    _layersControl.removeLayer(leafletLayers.baselayers[i]);\n                }\n                for (i in leafletLayers.overlays) {\n                    _layersControl.removeLayer(leafletLayers.overlays[i]);\n                }\n                map.removeControl(_layersControl);\n                delete _controls[mapId];\n            }\n\n            if (mustBeLoaded) {\n                _layersControl = _createLayersControl(mapId);\n                _controls[mapId] = _layersControl;\n                for (i in baselayers) {\n                    var hideOnSelector = isDefined(baselayers[i].layerOptions) &&\n                                         baselayers[i].layerOptions.showOnSelector === false;\n                    if (!hideOnSelector && isDefined(leafletLayers.baselayers[i])) {\n                        _layersControl.addBaseLayer(leafletLayers.baselayers[i], baselayers[i].name);\n                    }\n                }\n                for (i in overlays) {\n                \tvar hideOverlayOnSelector = isDefined(overlays[i].layerParams) &&\n                            overlays[i].layerParams.showOnSelector === false;\n                    if (!hideOverlayOnSelector && isDefined(leafletLayers.overlays[i])) {\n                        _layersControl.addOverlay(leafletLayers.overlays[i], overlays[i].name);\n                    }\n                }\n\n                map.addControl(_layersControl);\n            }\n            return mustBeLoaded;\n        }\n    };\n}]);\n\nangular.module(\"leaflet-directive\").service('leafletData', [\"$log\", \"$q\", \"leafletHelpers\", function ($log, $q, leafletHelpers) {\n    var getDefer = leafletHelpers.getDefer,\n        getUnresolvedDefer = leafletHelpers.getUnresolvedDefer,\n        setResolvedDefer = leafletHelpers.setResolvedDefer;\n\n    var _private = {};\n    var self = this;\n\n    var upperFirst = function (string) {\n        return string.charAt(0).toUpperCase() + string.slice(1);\n    };\n\n    var _privateItems = [\n        'map',\n        'tiles',\n        'layers',\n        'paths',\n        'markers',\n        'geoJSON',\n        'UTFGrid', //odd ball on naming convention keeping to not break\n        'decorations',\n        'directiveControls'];\n\n    //init\n    _privateItems.forEach(function(itemName){\n        _private[itemName] = {};\n    });\n\n    this.unresolveMap = function (scopeId) {\n        var id = leafletHelpers.obtainEffectiveMapId(_private.map, scopeId);\n        _privateItems.forEach(function (itemName) {\n            _private[itemName][id] = undefined;\n        });\n    };\n\n    //int repetitive stuff (get and sets)\n    _privateItems.forEach(function (itemName) {\n        var name = upperFirst(itemName);\n        self['set' + name] = function (lObject, scopeId) {\n            var defer = getUnresolvedDefer(_private[itemName], scopeId);\n            defer.resolve(lObject);\n            setResolvedDefer(_private[itemName], scopeId);\n        };\n\n        self['get' + name] = function (scopeId) {\n            var defer = getDefer(_private[itemName], scopeId);\n            return defer.promise;\n        };\n    });\n}]);\n\nangular.module(\"leaflet-directive\")\n.service('leafletDirectiveControlsHelpers', [\"$log\", \"leafletData\", \"leafletHelpers\", function ($log, leafletData, leafletHelpers) {\n    var _isDefined = leafletHelpers.isDefined,\n        _isString = leafletHelpers.isString,\n        _isObject = leafletHelpers.isObject,\n        _mainErrorHeader = leafletHelpers.errorHeader;\n\n    var _errorHeader = _mainErrorHeader + '[leafletDirectiveControlsHelpers';\n\n    var _extend = function(id, thingToAddName, createFn, cleanFn){\n        var _fnHeader = _errorHeader + '.extend] ';\n        var extender = {};\n        if(!_isDefined(thingToAddName)){\n            $log.error(_fnHeader + 'thingToAddName cannot be undefined');\n            return;\n        }\n\n        if(_isString(thingToAddName) && _isDefined(createFn) && _isDefined(cleanFn)){\n            extender[thingToAddName] = {\n                create: createFn,\n                clean: cleanFn\n            };\n        }\n        else if(_isObject(thingToAddName) && !_isDefined(createFn) && !_isDefined(cleanFn)){\n            extender = thingToAddName;\n        }\n        else{\n            $log.error(_fnHeader + 'incorrect arguments');\n            return;\n        }\n\n        //add external control to create / destroy markers without a watch\n        leafletData.getDirectiveControls().then(function(controls){\n            angular.extend(controls, extender);\n            leafletData.setDirectiveControls(controls, id);\n        });\n    };\n\n    return {\n        extend: _extend\n    };\n}]);\n\nangular.module(\"leaflet-directive\")\n.service('leafletGeoJsonHelpers', [\"leafletHelpers\", \"leafletIterators\", function (leafletHelpers, leafletIterators) {\n    var lHlp = leafletHelpers,\n    lIt = leafletIterators;\n    var Point = function(lat,lng){\n        this.lat = lat;\n        this.lng = lng;\n        return this;\n    };\n\n    var _getLat = function(value) {\n        if (Array.isArray(value) && value.length === 2) {\n            return value[1];\n        } else if (lHlp.isDefined(value.type) && value.type === 'Point') {\n            return +value.coordinates[1];\n        } else {\n            return +value.lat;\n        }\n    };\n\n    var _getLng = function(value) {\n        if (Array.isArray(value) && value.length === 2) {\n            return value[0];\n        } else if (lHlp.isDefined(value.type) && value.type === 'Point') {\n            return +value.coordinates[0];\n        } else {\n            return +value.lng;\n        }\n    };\n\n    var _validateCoords = function(coords) {\n        if (lHlp.isUndefined(coords)) {\n            return false;\n        }\n        if (lHlp.isArray(coords)) {\n            if (coords.length === 2 && lHlp.isNumber(coords[0]) && lHlp.isNumber(coords[1])) {\n                return true;\n            }\n        } else if (lHlp.isDefined(coords.type)) {\n            if (\n                coords.type === 'Point' && lHlp.isArray(coords.coordinates) &&\n                coords.coordinates.length === 2  &&\n                lHlp.isNumber(coords.coordinates[0]) &&\n                lHlp.isNumber(coords.coordinates[1])) {\n                    return true;\n                }\n            }\n\n            var ret = lIt.all(['lat', 'lng'], function(pos){\n                return lHlp.isDefined(coords[pos]) && lHlp.isNumber(coords[pos]);\n            });\n            return ret;\n        };\n\n        var _getCoords = function(value) {\n            if (!value || !_validateCoords(value)) {\n                return;\n            }\n            var p =  null;\n            if (Array.isArray(value) && value.length === 2) {\n                p = new Point(value[1], value[0]);\n            } else if (lHlp.isDefined(value.type) && value.type === 'Point') {\n                p = new Point(value.coordinates[1], value.coordinates[0]);\n            } else {\n                return value;\n            }\n            //note angular.merge is avail in angular 1.4.X we might want to fill it here\n            return angular.extend(value, p);//tap on lat, lng if it doesnt exist\n        };\n\n\n        return {\n            getLat: _getLat,\n            getLng: _getLng,\n            validateCoords: _validateCoords,\n            getCoords: _getCoords\n        };\n    }]);\n\nangular.module(\"leaflet-directive\").service('leafletHelpers', [\"$q\", \"$log\", function ($q, $log) {\n    var _errorHeader = '[AngularJS - Leaflet] ';\n    var _copy = angular.copy;\n    var _clone = _copy;\n    /*\n    For parsing paths to a field in an object\n\n    Example:\n    var obj = {\n        bike:{\n         1: 'hi'\n         2: 'foo'\n        }\n    };\n    _getObjectValue(obj,\"bike.1\") returns 'hi'\n    this is getPath in ui-gmap\n     */\n    var _getObjectValue = function(object, pathStr) {\n        var obj;\n        if(!object || !angular.isObject(object))\n            return;\n        //if the key is not a sting then we already have the value\n        if ((pathStr === null) || !angular.isString(pathStr)) {\n            return pathStr;\n        }\n        obj = object;\n        pathStr.split('.').forEach(function(value) {\n            if (obj) {\n                obj = obj[value];\n            }\n        });\n        return obj;\n    };\n\n    /*\n     Object Array Notation\n     _getObjectArrayPath(\"bike.one.two\")\n     returns:\n     'bike[\"one\"][\"two\"]'\n     */\n    var _getObjectArrayPath = function(pathStr){\n        return pathStr.split('.').reduce(function(previous, current) {\n            return previous + '[\"'+ current + '\"]';\n        });\n    };\n\n    /* Object Dot Notation\n     _getObjectPath([\"bike\",\"one\",\"two\"])\n     returns:\n     \"bike.one.two\"\n     */\n    var _getObjectDotPath = function(arrayOfStrings){\n        return arrayOfStrings.reduce(function(previous, current) {\n            return previous + '.' + current;\n        });\n    };\n\n    function _obtainEffectiveMapId(d, mapId) {\n        var id, i;\n        if (!angular.isDefined(mapId)) {\n        if (Object.keys(d).length === 0) {\n            id = \"main\";\n        } else if (Object.keys(d).length >= 1) {\n            for (i in d) {\n                if (d.hasOwnProperty(i)) {\n                    id = i;\n                }\n            }\n        } else {\n                $log.error(_errorHeader + \"- You have more than 1 map on the DOM, you must provide the map ID to the leafletData.getXXX call\");\n            }\n        } else {\n            id = mapId;\n        }\n\n        return id;\n    }\n\n    function _getUnresolvedDefer(d, mapId) {\n        var id = _obtainEffectiveMapId(d, mapId),\n            defer;\n\n        if (!angular.isDefined(d[id]) || d[id].resolvedDefer === true) {\n            defer = $q.defer();\n            d[id] = {\n                defer: defer,\n                resolvedDefer: false\n            };\n        } else {\n            defer = d[id].defer;\n        }\n\n        return defer;\n    }\n\n    var _isDefined = function(value) {\n        return angular.isDefined(value) && value !== null;\n    };\n    var _isUndefined = function(value){\n        return !_isDefined(value);\n    };\n\n    // BEGIN DIRECT PORT FROM AngularJS code base\n\n    var SPECIAL_CHARS_REGEXP = /([\\:\\-\\_]+(.))/g;\n\n    var MOZ_HACK_REGEXP = /^moz([A-Z])/;\n\n    var PREFIX_REGEXP = /^((?:x|data)[\\:\\-_])/i;\n\n    /**\n    Converts snake_case to camelCase.\n    Also there is special case for Moz prefix starting with upper case letter.\n    @param name Name to normalize\n     */\n\n    var camelCase = function(name) {\n      return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {\n        if (offset) {\n          return letter.toUpperCase();\n        } else {\n          return letter;\n        }\n      }).replace(MOZ_HACK_REGEXP, \"Moz$1\");\n    };\n\n\n    /**\n    Converts all accepted directives format into proper directive name.\n    @param name Name to normalize\n     */\n\n     var directiveNormalize = function(name) {\n      return camelCase(name.replace(PREFIX_REGEXP, \"\"));\n    };\n\n    // END AngularJS port\n\n    return {\n        camelCase: camelCase,\n        directiveNormalize: directiveNormalize,\n        copy:_copy,\n        clone:_clone,\n        errorHeader: _errorHeader,\n        getObjectValue: _getObjectValue,\n        getObjectArrayPath:_getObjectArrayPath,\n        getObjectDotPath: _getObjectDotPath,\n        defaultTo: function(val, _default){\n            return _isDefined(val) ? val : _default;\n        },\n        //mainly for checking attributes of directives lets keep this minimal (on what we accept)\n        isTruthy: function(val){\n            return val === 'true' || val === true;\n        },\n        //Determine if a reference is {}\n        isEmpty: function(value) {\n            return Object.keys(value).length === 0;\n        },\n\n        //Determine if a reference is undefined or {}\n        isUndefinedOrEmpty: function (value) {\n            return (angular.isUndefined(value) || value === null) || Object.keys(value).length === 0;\n        },\n\n        // Determine if a reference is defined\n        isDefined: _isDefined,\n        isUndefined:_isUndefined,\n        isNumber: angular.isNumber,\n        isString: angular.isString,\n        isArray: angular.isArray,\n        isObject: angular.isObject,\n        isFunction: angular.isFunction,\n        equals: angular.equals,\n\n        isValidCenter: function(center) {\n            return angular.isDefined(center) && angular.isNumber(center.lat) &&\n                   angular.isNumber(center.lng) && angular.isNumber(center.zoom);\n        },\n\n        isValidPoint: function(point) {\n            if (!angular.isDefined(point)) {\n                return false;\n            }\n            if (angular.isArray(point)) {\n                return point.length === 2 && angular.isNumber(point[0]) && angular.isNumber(point[1]);\n            }\n            return angular.isNumber(point.lat) && angular.isNumber(point.lng);\n        },\n\n        isSameCenterOnMap: function(centerModel, map) {\n            var mapCenter = map.getCenter();\n            var zoom = map.getZoom();\n            if (centerModel.lat && centerModel.lng &&\n                mapCenter.lat.toFixed(4) === centerModel.lat.toFixed(4) &&\n                mapCenter.lng.toFixed(4) === centerModel.lng.toFixed(4) &&\n                zoom === centerModel.zoom) {\n                    return true;\n            }\n            return false;\n        },\n\n        safeApply: function($scope, fn) {\n            var phase = $scope.$root.$$phase;\n            if (phase === '$apply' || phase === '$digest') {\n                $scope.$eval(fn);\n            } else {\n                $scope.$evalAsync(fn);\n            }\n        },\n\n        obtainEffectiveMapId: _obtainEffectiveMapId,\n\n        getDefer: function(d, mapId) {\n            var id = _obtainEffectiveMapId(d, mapId),\n                defer;\n            if (!angular.isDefined(d[id]) || d[id].resolvedDefer === false) {\n                defer = _getUnresolvedDefer(d, mapId);\n            } else {\n                defer = d[id].defer;\n            }\n            return defer;\n        },\n\n        getUnresolvedDefer: _getUnresolvedDefer,\n\n        setResolvedDefer: function(d, mapId) {\n            var id = _obtainEffectiveMapId(d, mapId);\n            d[id].resolvedDefer = true;\n        },\n\n        rangeIsSupported: function() {\n            var testrange = document.createElement('input');\n            testrange.setAttribute('type', 'range');\n            return testrange.type === 'range';\n        },\n\n        FullScreenControlPlugin: {\n            isLoaded: function() {\n                return angular.isDefined(L.Control.Fullscreen);\n            }\n        },\n\n        MiniMapControlPlugin: {\n            isLoaded: function() {\n                return angular.isDefined(L.Control.MiniMap);\n            }\n        },\n\n        AwesomeMarkersPlugin: {\n            isLoaded: function() {\n                return angular.isDefined(L.AwesomeMarkers) && angular.isDefined(L.AwesomeMarkers.Icon);\n            },\n            is: function(icon) {\n                if (this.isLoaded()) {\n                    return icon instanceof L.AwesomeMarkers.Icon;\n                } else {\n                    return false;\n                }\n            },\n            equal: function (iconA, iconB) {\n                if (!this.isLoaded()) {\n                    return false;\n                }\n                if (this.is(iconA)) {\n                    return angular.equals(iconA, iconB);\n                } else {\n                    return false;\n                }\n            }\n        },\n\n        VectorMarkersPlugin: {\n            isLoaded: function() {\n                return angular.isDefined(L.VectorMarkers) && angular.isDefined(L.VectorMarkers.Icon);\n            },\n            is: function(icon) {\n                if (this.isLoaded()) {\n                    return icon instanceof L.VectorMarkers.Icon;\n                } else {\n                    return false;\n                }\n            },\n            equal: function (iconA, iconB) {\n                if (!this.isLoaded()) {\n                    return false;\n                }\n                if (this.is(iconA)) {\n                    return angular.equals(iconA, iconB);\n                } else {\n                    return false;\n                }\n            }\n        },\n\n        DomMarkersPlugin: {\n            isLoaded: function () {\n                if (angular.isDefined(L.DomMarkers) && angular.isDefined(L.DomMarkers.Icon)) {\n                    return true;\n                } else {\n                    return false;\n                }\n            },\n            is: function (icon) {\n                if (this.isLoaded()) {\n                    return icon instanceof L.DomMarkers.Icon;\n                } else {\n                    return false;\n                }\n            },\n            equal: function (iconA, iconB) {\n                if (!this.isLoaded()) {\n                    return false;\n                }\n                if (this.is(iconA)) {\n                    return angular.equals(iconA, iconB);\n                } else {\n                    return false;\n                }\n            }\n        },\n\n        PolylineDecoratorPlugin: {\n            isLoaded: function() {\n                if (angular.isDefined(L.PolylineDecorator)) {\n                    return true;\n                } else {\n                    return false;\n                }\n            },\n            is: function(decoration) {\n                if (this.isLoaded()) {\n                    return decoration instanceof L.PolylineDecorator;\n                } else {\n                    return false;\n                }\n            },\n            equal: function(decorationA, decorationB) {\n                if (!this.isLoaded()) {\n                    return false;\n                }\n                if (this.is(decorationA)) {\n                    return angular.equals(decorationA, decorationB);\n                } else {\n                    return false;\n                }\n            }\n        },\n\n        MakiMarkersPlugin: {\n            isLoaded: function() {\n                if (angular.isDefined(L.MakiMarkers) && angular.isDefined(L.MakiMarkers.Icon)) {\n                    return true;\n                } else {\n                    return false;\n                }\n            },\n            is: function(icon) {\n                if (this.isLoaded()) {\n                    return icon instanceof L.MakiMarkers.Icon;\n                } else {\n                    return false;\n                }\n            },\n            equal: function (iconA, iconB) {\n                if (!this.isLoaded()) {\n                    return false;\n                }\n                if (this.is(iconA)) {\n                    return angular.equals(iconA, iconB);\n                } else {\n                    return false;\n                }\n            }\n        },\n        ExtraMarkersPlugin: {\n            isLoaded: function () {\n                if (angular.isDefined(L.ExtraMarkers) && angular.isDefined(L.ExtraMarkers.Icon)) {\n                    return true;\n                } else {\n                    return false;\n                }\n            },\n            is: function (icon) {\n                if (this.isLoaded()) {\n                    return icon instanceof L.ExtraMarkers.Icon;\n                } else {\n                    return false;\n                }\n            },\n            equal: function (iconA, iconB) {\n                if (!this.isLoaded()) {\n                    return false;\n                }\n                if (this.is(iconA)) {\n                    return angular.equals(iconA, iconB);\n                } else {\n                    return false;\n                }\n            }\n        },\n        LabelPlugin: {\n            isLoaded: function() {\n                return angular.isDefined(L.Label);\n            },\n            is: function(layer) {\n                if (this.isLoaded()) {\n                    return layer instanceof L.MarkerClusterGroup;\n                } else {\n                    return false;\n                }\n            }\n        },\n        MarkerClusterPlugin: {\n            isLoaded: function() {\n                return angular.isDefined(L.MarkerClusterGroup);\n            },\n            is: function(layer) {\n                if (this.isLoaded()) {\n                    return layer instanceof L.MarkerClusterGroup;\n                } else {\n                    return false;\n                }\n            }\n        },\n        GoogleLayerPlugin: {\n            isLoaded: function() {\n                return angular.isDefined(L.Google);\n            },\n            is: function(layer) {\n                if (this.isLoaded()) {\n                    return layer instanceof L.Google;\n                } else {\n                    return false;\n                }\n            }\n        },\n        LeafletProviderPlugin: {\n            isLoaded: function() {\n                return angular.isDefined(L.TileLayer.Provider);\n            },\n            is: function(layer) {\n                if (this.isLoaded()) {\n                    return layer instanceof L.TileLayer.Provider;\n                } else {\n                    return false;\n                }\n            }\n        },          \n        ChinaLayerPlugin: {\n            isLoaded: function() {\n                return angular.isDefined(L.tileLayer.chinaProvider);\n            }\n        },\n        HeatLayerPlugin: {\n            isLoaded: function() {\n                return angular.isDefined(L.heatLayer);\n            }\n        },\n        WebGLHeatMapLayerPlugin: {\n            isLoaded: function() {\n                return angular.isDefined(L.TileLayer.WebGLHeatMap);\n            }\n        },\n        BingLayerPlugin: {\n            isLoaded: function() {\n                return angular.isDefined(L.BingLayer);\n            },\n            is: function(layer) {\n                if (this.isLoaded()) {\n                    return layer instanceof L.BingLayer;\n                } else {\n                    return false;\n                }\n            }\n        },\n        WFSLayerPlugin: {\n            isLoaded: function() {\n                return L.GeoJSON.WFS !== undefined;\n            },\n            is: function(layer) {\n                if (this.isLoaded()) {\n                    return layer instanceof L.GeoJSON.WFS;\n                } else {\n                    return false;\n                }\n            }\n        },\n        AGSBaseLayerPlugin: {\n            isLoaded: function() {\n                return L.esri !== undefined && L.esri.basemapLayer !== undefined;\n            },\n            is: function (layer) {\n                if (this.isLoaded()) {\n                    return layer instanceof L.esri.basemapLayer;\n                } else {\n                    return false;\n                }\n            }\n        },\n        AGSLayerPlugin: {\n            isLoaded: function() {\n                return lvector !== undefined && lvector.AGS !== undefined;\n            },\n            is: function(layer) {\n                if (this.isLoaded()) {\n                    return layer instanceof lvector.AGS;\n                } else {\n                    return false;\n                }\n            }\n        },\n        AGSFeatureLayerPlugin: {\n            isLoaded: function() {\n                return L.esri !== undefined && L.esri.featureLayer !== undefined;\n            },\n            is: function (layer) {\n                if (this.isLoaded()) {\n                    return layer instanceof L.esri.featureLayer;\n                } else {\n                    return false;\n                }\n            }\n        },\n        AGSTiledMapLayerPlugin: {\n            isLoaded: function() {\n                return L.esri !== undefined && L.esri.tiledMapLayer !== undefined;\n            },\n            is: function (layer) {\n                if (this.isLoaded()) {\n                    return layer instanceof L.esri.tiledMapLayer;\n                } else {\n                    return false;\n                }\n            }\n        },\n        AGSDynamicMapLayerPlugin: {\n            isLoaded: function () {\n                return L.esri !== undefined && L.esri.dynamicMapLayer !== undefined;\n            },\n            is: function (layer) {\n                if (this.isLoaded()) {\n                    return layer instanceof L.esri.dynamicMapLayer;\n                } else {\n                    return false;\n                }\n            }\n        },\n        AGSImageMapLayerPlugin: {\n            isLoaded: function () {\n                return L.esri !== undefined && L.esri.imageMapLayer !== undefined;\n            },\n            is: function (layer) {\n                if (this.isLoaded()) {\n                    return layer instanceof L.esri.imageMapLayer;\n                } else {\n                    return false;\n                }\n            }\n        },\n        AGSClusteredLayerPlugin: {\n            isLoaded: function () {\n                return L.esri !== undefined && L.esri.clusteredFeatureLayer !== undefined;\n            },\n            is: function (layer) {\n                if (this.isLoaded()) {\n                    return layer instanceof L.esri.clusteredFeatureLayer;\n                } else {\n                    return false;\n                }\n            }\n        },\n        AGSHeatmapLayerPlugin: {\n            isLoaded: function () {\n                return L.esri !== undefined && L.esri.heatmapFeatureLayer !== undefined;\n            },\n            is: function (layer) {\n                if (this.isLoaded()) {\n                    return layer instanceof L.esri.heatmapFeatureLayer;\n                } else {\n                    return false;\n                }\n            }\n        },\n        YandexLayerPlugin: {\n            isLoaded: function() {\n                return angular.isDefined(L.Yandex);\n            },\n            is: function(layer) {\n                if (this.isLoaded()) {\n                    return layer instanceof L.Yandex;\n                } else {\n                    return false;\n                }\n            }\n        },\n        GeoJSONPlugin: {\n            isLoaded: function(){\n                return angular.isDefined(L.TileLayer.GeoJSON);\n            },\n            is: function(layer) {\n                if (this.isLoaded()) {\n                    return layer instanceof L.TileLayer.GeoJSON;\n                } else {\n                    return false;\n                }\n            }\n        },\n        UTFGridPlugin: {\n            isLoaded: function(){\n                return angular.isDefined(L.UtfGrid);\n            },\n            is: function(layer) {\n                if (this.isLoaded()) {\n                    return layer instanceof L.UtfGrid;\n                } else {\n                    $log.error('[AngularJS - Leaflet] No UtfGrid plugin found.');\n                    return false;\n                }\n            }\n        },\n        CartoDB: {\n            isLoaded: function(){\n                return cartodb;\n            },\n            is: function(/*layer*/) {\n                return true;\n                /*\n                if (this.isLoaded()) {\n                    return layer instanceof L.TileLayer.GeoJSON;\n                } else {\n                    return false;\n                }*/\n            }\n        },\n        Leaflet: {\n            DivIcon: {\n                is: function(icon) {\n                    return icon instanceof L.DivIcon;\n                },\n                equal: function(iconA, iconB) {\n                    if (this.is(iconA)) {\n                        return angular.equals(iconA, iconB);\n                    } else {\n                        return false;\n                    }\n                }\n            },\n            Icon: {\n                is: function(icon) {\n                    return icon instanceof L.Icon;\n                },\n                equal: function(iconA, iconB) {\n                    if (this.is(iconA)) {\n                        return angular.equals(iconA, iconB);\n                    } else {\n                        return false;\n                    }\n                }\n            }\n        },\n        /*\n         watchOptions - object to set deep nested watches and turn off watches all together\n         (rely on control / functional updates)\n         watchOptions - Object\n             doWatch:boolean\n             isDeep:boolean (sets $watch(function,isDeep))\n             individual\n                 doWatch:boolean\n                 isDeep:boolean\n         */\n        //legacy defaults\n        watchOptions: {\n            doWatch:true,\n            isDeep: true,\n            individual:{\n                doWatch:true,\n                isDeep: true\n            }\n        }\n    };\n}]);\n\nangular.module('leaflet-directive').service('leafletIterators', [\"$log\", \"leafletHelpers\", function ($log, leafletHelpers) {\n\n  var lHlp = leafletHelpers,\n  errorHeader = leafletHelpers.errorHeader + 'leafletIterators: ';\n\n  //BEGIN COPY from underscore\n  var _keys = Object.keys;\n  var _isFunction = lHlp.isFunction;\n  var _isObject = lHlp.isObject;\n\n  // Helper for collection methods to determine whether a collection\n  // should be iterated as an array or as an object\n  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n\n  var _isArrayLike = function(collection) {\n    var length = collection !== null && collection.length;\n    return  lHlp.isNumber(length) && length >= 0 && length <= MAX_ARRAY_INDEX;\n  };\n\n  // Keep the identity function around for default iteratees.\n  var _identity = function(value) {\n    return value;\n  };\n\n  var _property = function(key) {\n    return function(obj) {\n      return obj === null ? void 0 : obj[key];\n    };\n  };\n\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  var optimizeCb = function(func, context, argCount) {\n    if (context === void 0) return func;\n    switch (argCount === null ? 3 : argCount) {\n      case 1: return function(value) {\n        return func.call(context, value);\n      };\n      case 2: return function(value, other) {\n        return func.call(context, value, other);\n      };\n      case 3: return function(value, index, collection) {\n        return func.call(context, value, index, collection);\n      };\n      case 4: return function(accumulator, value, index, collection) {\n        return func.call(context, accumulator, value, index, collection);\n      };\n    }\n    return function() {\n      return func.apply(context, arguments);\n    };\n  };\n\n  // An internal function for creating assigner functions.\n  var createAssigner = function(keysFunc, undefinedOnly) {\n    return function(obj) {\n      var length = arguments.length;\n      if (length < 2 || obj === null) return obj;\n      for (var index = 1; index < length; index++) {\n        var source = arguments[index],\n            keys = keysFunc(source),\n            l = keys.length;\n        for (var i = 0; i < l; i++) {\n          var key = keys[i];\n          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];\n        }\n      }\n      return obj;\n    };\n  };\n\n  // Assigns a given object with all the own properties in the passed-in object(s)\n  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n  var _extendOwn, _assign = null;\n  _extendOwn = _assign = createAssigner(_keys);\n\n  // Returns whether an object has a given set of `key:value` pairs.\n  var _isMatch = function(object, attrs) {\n    var keys = _keys(attrs), length = keys.length;\n    if (object === null) return !length;\n    var obj = Object(object);\n    for (var i = 0; i < length; i++) {\n      var key = keys[i];\n      if (attrs[key] !== obj[key] || !(key in obj)) return false;\n    }\n    return true;\n  };\n\n  // Returns a predicate for checking whether an object has a given set of\n  // `key:value` pairs.\n  var _matcher, _matches = null;\n  _matcher = _matches = function(attrs) {\n    attrs = _extendOwn({}, attrs);\n    return function(obj) {\n      return _isMatch(obj, attrs);\n    };\n  };\n\n\n  // A mostly-internal function to generate callbacks that can be applied\n  // to each element in a collection, returning the desired result  either\n  // identity, an arbitrary callback, a property matcher, or a property accessor.\n  var cb = function(value, context, argCount) {\n    if (value === null) return _identity;\n    if (_isFunction(value)) return optimizeCb(value, context, argCount);\n    if (_isObject(value)) return _matcher(value);\n    return _property(value);\n  };\n\n  var _every, _all = null;\n  _every = _all = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !_isArrayLike(obj) && _keys(obj),\n    length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (!predicate(obj[currentKey], currentKey, obj)) return false;\n    }\n    return true;\n  };\n\n  //END COPY fron underscore\n\n  var _hasErrors = function(collection, cb, ignoreCollection, cbName){\n    if(!ignoreCollection) {\n      if (!lHlp.isDefined(collection) || !lHlp.isDefined(cb)) {\n        return true;\n      }\n    }\n    if(!lHlp.isFunction(cb)){\n      cbName = lHlp.defaultTo(cb,'cb');\n      $log.error(errorHeader + cbName + ' is not a function');\n      return true;\n    }\n    return false;\n  };\n\n  var _iterate = function(collection, externalCb, internalCb){\n    if(_hasErrors(undefined, internalCb, true, 'internalCb')){\n      return;\n    }\n    if(!_hasErrors(collection, externalCb)){\n      for(var key in collection){\n          if (collection.hasOwnProperty(key)) {\n              internalCb(collection[key], key);\n          }\n      }\n    }\n  };\n\n  //see http://jsperf.com/iterators/3\n  //utilizing for in is way faster\n  var _each = function(collection, cb){\n    _iterate(collection, cb, function(val, key){\n      cb(val, key);\n    });\n  };\n\n  return {\n    each:_each,\n    forEach: _each,\n    every: _every,\n    all: _all\n  };\n}]);\n\nangular.module(\"leaflet-directive\")\n.factory('leafletLayerHelpers', [\"$rootScope\", \"$log\", \"$q\", \"leafletHelpers\", \"leafletIterators\", function ($rootScope, $log, $q, leafletHelpers, leafletIterators) {\n    var Helpers = leafletHelpers;\n    var isString = leafletHelpers.isString;\n    var isObject = leafletHelpers.isObject;\n    var isArray = leafletHelpers.isArray;\n    var isDefined = leafletHelpers.isDefined;\n    var errorHeader = leafletHelpers.errorHeader;\n    var $it = leafletIterators;\n\n    var utfGridCreateLayer = function(params) {\n        if (!Helpers.UTFGridPlugin.isLoaded()) {\n            $log.error('[AngularJS - Leaflet] The UTFGrid plugin is not loaded.');\n            return;\n        }\n        var utfgrid = new L.UtfGrid(params.url, params.pluginOptions);\n\n        utfgrid.on('mouseover', function(e) {\n            $rootScope.$broadcast('leafletDirectiveMap.utfgridMouseover', e);\n        });\n\n        utfgrid.on('mouseout', function(e) {\n            $rootScope.$broadcast('leafletDirectiveMap.utfgridMouseout', e);\n        });\n\n        utfgrid.on('click', function(e) {\n            $rootScope.$broadcast('leafletDirectiveMap.utfgridClick', e);\n        });\n\n        utfgrid.on('mousemove', function(e) {\n            $rootScope.$broadcast('leafletDirectiveMap.utfgridMousemove', e);\n        });\n\n        return utfgrid;\n    };\n\n    var layerTypes = {\n        xyz: {\n            mustHaveUrl: true,\n            createLayer: function(params) {\n                return L.tileLayer(params.url, params.options);\n            }\n        },\n        mapbox: {\n            mustHaveKey: true,\n            createLayer: function(params) {\n                var version = 3;\n                if(isDefined(params.options.version) && params.options.version === 4) {\n                    version = params.options.version;\n                }\n                var url = version === 3?\n                    '//{s}.tiles.mapbox.com/v3/' + params.key + '/{z}/{x}/{y}.png':\n                    '//api.tiles.mapbox.com/v4/' + params.key + '/{z}/{x}/{y}.png?access_token=' + params.apiKey;\n                return L.tileLayer(url, params.options);\n            }\n        },\n        geoJSON: {\n            mustHaveUrl: true,\n            createLayer: function(params) {\n                if (!Helpers.GeoJSONPlugin.isLoaded()) {\n                    return;\n                }\n                return new L.TileLayer.GeoJSON(params.url, params.pluginOptions, params.options);\n            }\n        },\n        geoJSONShape: {\n            mustHaveUrl: false,\n            createLayer: function(params) {\n                        return new L.GeoJSON(params.data,\n                            params.options);\n            }\n        },\n        geoJSONAwesomeMarker: {\n            mustHaveUrl: false,\n            createLayer: function(params) {\n                    return new L.geoJson(params.data, {\n                        pointToLayer: function (feature, latlng) {\n                            return L.marker(latlng, {icon: L.AwesomeMarkers.icon(params.icon)});\n                    }\n                });\n            }\n        },\n        geoJSONVectorMarker: {\n            mustHaveUrl: false,\n            createLayer: function(params) {\n                    return new L.geoJson(params.data, {\n                        pointToLayer: function (feature, latlng) {\n                            return L.marker(latlng, {icon: L.VectorMarkers.icon(params.icon)});\n                    }\n                });\n            }\n        },\n        utfGrid: {\n            mustHaveUrl: true,\n            createLayer: utfGridCreateLayer\n        },\n        cartodbTiles: {\n            mustHaveKey: true,\n            createLayer: function(params) {\n                var url = '//' + params.user + '.cartodb.com/api/v1/map/' + params.key + '/{z}/{x}/{y}.png';\n                return L.tileLayer(url, params.options);\n            }\n        },\n        cartodbUTFGrid: {\n            mustHaveKey: true,\n            mustHaveLayer : true,\n            createLayer: function(params) {\n                params.url = '//' + params.user + '.cartodb.com/api/v1/map/' + params.key + '/' + params.layer + '/{z}/{x}/{y}.grid.json';\n                return utfGridCreateLayer(params);\n            }\n        },\n        cartodbInteractive: {\n            mustHaveKey: true,\n            mustHaveLayer : true,\n            createLayer: function(params) {\n                var tilesURL = '//' + params.user + '.cartodb.com/api/v1/map/' + params.key + '/{z}/{x}/{y}.png';\n                var tileLayer = L.tileLayer(tilesURL, params.options);\n                params.url = '//' + params.user + '.cartodb.com/api/v1/map/' + params.key + '/' + params.layer + '/{z}/{x}/{y}.grid.json';\n                var utfLayer = utfGridCreateLayer(params);\n                return L.layerGroup([tileLayer, utfLayer]);\n            }\n        },\n        wms: {\n            mustHaveUrl: true,\n            createLayer: function(params) {\n                return L.tileLayer.wms(params.url, params.options);\n            }\n        },\n        wmts: {\n            mustHaveUrl: true,\n            createLayer: function(params) {\n                return L.tileLayer.wmts(params.url, params.options);\n            }\n        },\n        wfs: {\n            mustHaveUrl: true,\n            mustHaveLayer : true,\n            createLayer: function(params) {\n                if (!Helpers.WFSLayerPlugin.isLoaded()) {\n                    return;\n                }\n                var options = angular.copy(params.options);\n                if(options.crs && 'string' === typeof options.crs) {\n                    /*jshint -W061 */\n                    options.crs = eval(options.crs);\n                }\n                return new L.GeoJSON.WFS(params.url, params.layer, options);\n            }\n        },\n        group: {\n            mustHaveUrl: false,\n            createLayer: function (params) {\n                var lyrs = [];\n                $it.each(params.options.layers, function(l){\n                  lyrs.push(createLayer(l));\n                });\n                params.options.loadedDefer = function() {\n                    var defers = [];\n                    if(isDefined(params.options.layers)) {\n                        for (var i = 0; i < params.options.layers.length; i++) {\n                            var d = params.options.layers[i].layerOptions.loadedDefer;\n                            if(isDefined(d)) {\n                                defers.push(d);\n                            }\n                        }\n                    }\n                    return defers;\n                };\n                return L.layerGroup(lyrs);\n            }\n        },\n        featureGroup: {\n            mustHaveUrl: false,\n            createLayer: function () {\n                return L.featureGroup();\n            }\n        },\n        google: {\n            mustHaveUrl: false,\n            createLayer: function(params) {\n                var type = params.type || 'SATELLITE';\n                if (!Helpers.GoogleLayerPlugin.isLoaded()) {\n                    return;\n                }\n                return new L.Google(type, params.options);\n            }\n        },\n        here: {\n            mustHaveUrl: false,\n            createLayer: function(params) {\n                var provider = params.provider || 'HERE.terrainDay';\n                if (!Helpers.LeafletProviderPlugin.isLoaded()) {\n                    return;\n                }\n                return new L.TileLayer.Provider(provider, params.options);\n            }\n        },\n        china:{\n            mustHaveUrl:false,\n            createLayer:function(params){\n                var type = params.type || '';\n                if(!Helpers.ChinaLayerPlugin.isLoaded()){\n                    return;\n                }\n                return L.tileLayer.chinaProvider(type, params.options);\n            }\n        },\n        agsBase: {\n            mustHaveLayer : true,\n            createLayer: function (params) {\n                if (!Helpers.AGSBaseLayerPlugin.isLoaded()) {\n                    return;\n                }\n                return L.esri.basemapLayer(params.layer, params.options);\n            }\n        },\n        ags: {\n            mustHaveUrl: true,\n            createLayer: function(params) {\n                if (!Helpers.AGSLayerPlugin.isLoaded()) {\n                    return;\n                }\n\n                var options = angular.copy(params.options);\n                angular.extend(options, {\n                    url: params.url\n                });\n                var layer = new lvector.AGS(options);\n                layer.onAdd = function(map) {\n                    this.setMap(map);\n                };\n                layer.onRemove = function() {\n                    this.setMap(null);\n                };\n                return layer;\n            }\n        },\n        agsFeature: {\n            mustHaveUrl: true,\n            createLayer: function(params) {\n                if (!Helpers.AGSFeatureLayerPlugin.isLoaded()) {\n                    $log.warn(errorHeader + ' The esri plugin is not loaded.');\n                    return;\n                }\n\n                params.options.url = params.url;\n\n                var layer = L.esri.featureLayer(params.options);\n                var load = function() {\n                    if(isDefined(params.options.loadedDefer)) {\n                        params.options.loadedDefer.resolve();\n                    }\n                };\n                layer.on('loading', function() {\n                    params.options.loadedDefer = $q.defer();\n                    layer.off('load', load);\n                    layer.on('load', load);\n                });\n\n                return layer;\n            }\n        },\n        agsTiled: {\n            mustHaveUrl: true,\n            createLayer: function(params) {\n                if (!Helpers.AGSTiledMapLayerPlugin.isLoaded()) {\n                    $log.warn(errorHeader + ' The esri plugin is not loaded.');\n                    return;\n                }\n\n                params.options.url = params.url;\n\n                return L.esri.tiledMapLayer(params.options);\n            }\n        },\n        agsDynamic: {\n            mustHaveUrl: true,\n            createLayer: function(params) {\n                if (!Helpers.AGSDynamicMapLayerPlugin.isLoaded()) {\n                    $log.warn(errorHeader + ' The esri plugin is not loaded.');\n                    return;\n                }\n\n                params.options.url = params.url;\n\n                return L.esri.dynamicMapLayer(params.options);\n            }\n        },\n        agsImage: {\n            mustHaveUrl: true,\n            createLayer: function(params) {\n                if (!Helpers.AGSImageMapLayerPlugin.isLoaded()) {\n                    $log.warn(errorHeader + ' The esri plugin is not loaded.');\n                    return;\n                }\n                 params.options.url = params.url;\n\n                return L.esri.imageMapLayer(params.options);\n            }\n        },\n        agsClustered: {\n            mustHaveUrl: true,\n            createLayer: function(params) {\n                if (!Helpers.AGSClusteredLayerPlugin.isLoaded()) {\n                    $log.warn(errorHeader + ' The esri clustered layer plugin is not loaded.');\n                    return;\n                }\n\n                if(!Helpers.MarkerClusterPlugin.isLoaded()) {\n                    $log.warn(errorHeader + ' The markercluster plugin is not loaded.');\n                    return;\n                }\n                return L.esri.clusteredFeatureLayer(params.url, params.options);\n            }\n        },\n        agsHeatmap: {\n            mustHaveUrl: true,\n            createLayer: function(params) {\n                if (!Helpers.AGSHeatmapLayerPlugin.isLoaded()) {\n                    $log.warn(errorHeader + ' The esri heatmap layer plugin is not loaded.');\n                    return;\n                }\n\n                if(!Helpers.HeatLayerPlugin.isLoaded()) {\n                    $log.warn(errorHeader + ' The heatlayer plugin is not loaded.');\n                    return;\n                }\n                return L.esri.heatmapFeatureLayer(params.url, params.options);\n            }\n        },\n        markercluster: {\n            mustHaveUrl: false,\n            createLayer: function(params) {\n                if (!Helpers.MarkerClusterPlugin.isLoaded()) {\n                    $log.warn(errorHeader + ' The markercluster plugin is not loaded.');\n                    return;\n                }\n                return new L.MarkerClusterGroup(params.options);\n            }\n        },\n        bing: {\n            mustHaveUrl: false,\n            createLayer: function(params) {\n                if (!Helpers.BingLayerPlugin.isLoaded()) {\n                    return;\n                }\n                return new L.BingLayer(params.key, params.options);\n            }\n        },\n        webGLHeatmap: {\n            mustHaveUrl: false,\n            mustHaveData: true,\n            createLayer: function(params) {\n                if (!Helpers.WebGLHeatMapLayerPlugin.isLoaded()) {\n                    return;\n                }\n                var layer = new L.TileLayer.WebGLHeatMap(params.options);\n                if (isDefined(params.data)) {\n                    layer.setData(params.data);\n                }\n\n                return layer;\n            }\n        },\n        heat: {\n            mustHaveUrl: false,\n            mustHaveData: true,\n            createLayer: function(params) {\n                if (!Helpers.HeatLayerPlugin.isLoaded()) {\n                    return;\n                }\n                var layer = new L.heatLayer();\n\n                if (isArray(params.data)) {\n                    layer.setLatLngs(params.data);\n                }\n\n                if (isObject(params.options)) {\n                    layer.setOptions(params.options);\n                }\n\n                return layer;\n            }\n        },\n        yandex: {\n            mustHaveUrl: false,\n            createLayer: function(params) {\n                var type = params.type || 'map';\n                if (!Helpers.YandexLayerPlugin.isLoaded()) {\n                    return;\n                }\n                return new L.Yandex(type, params.options);\n            }\n        },\n        imageOverlay: {\n            mustHaveUrl: true,\n            mustHaveBounds : true,\n            createLayer: function(params) {\n                return L.imageOverlay(params.url, params.bounds, params.options);\n            }\n        },\n        iip: {\n            mustHaveUrl: true,\n            createLayer: function(params) {\n                return L.tileLayer.iip(params.url, params.options);\n            }\n        },\n\n        // This \"custom\" type is used to accept every layer that user want to define himself.\n        // We can wrap these custom layers like heatmap or yandex, but it means a lot of work/code to wrap the world,\n        // so we let user to define their own layer outside the directive,\n        // and pass it on \"createLayer\" result for next processes\n        custom: {\n            createLayer: function (params) {\n                if (params.layer instanceof L.Class) {\n                    return angular.copy(params.layer);\n                }\n                else {\n                    $log.error('[AngularJS - Leaflet] A custom layer must be a leaflet Class');\n                }\n            }\n        },\n        cartodb: {\n            mustHaveUrl: true,\n            createLayer: function(params) {\n                return cartodb.createLayer(params.map, params.url);\n            }\n        }\n    };\n\n    function isValidLayerType(layerDefinition) {\n        // Check if the baselayer has a valid type\n        if (!isString(layerDefinition.type)) {\n            $log.error('[AngularJS - Leaflet] A layer must have a valid type defined.');\n            return false;\n        }\n\n        if (Object.keys(layerTypes).indexOf(layerDefinition.type) === -1) {\n            $log.error('[AngularJS - Leaflet] A layer must have a valid type: ' + Object.keys(layerTypes));\n            return false;\n        }\n\n        // Check if the layer must have an URL\n        if (layerTypes[layerDefinition.type].mustHaveUrl && !isString(layerDefinition.url)) {\n            $log.error('[AngularJS - Leaflet] A base layer must have an url');\n            return false;\n        }\n\n        if (layerTypes[layerDefinition.type].mustHaveData && !isDefined(layerDefinition.data)) {\n            $log.error('[AngularJS - Leaflet] The base layer must have a \"data\" array attribute');\n            return false;\n        }\n\n        if(layerTypes[layerDefinition.type].mustHaveLayer && !isDefined(layerDefinition.layer)) {\n            $log.error('[AngularJS - Leaflet] The type of layer ' + layerDefinition.type + ' must have an layer defined');\n            return false;\n        }\n\n        if (layerTypes[layerDefinition.type].mustHaveBounds && !isDefined(layerDefinition.bounds)) {\n            $log.error('[AngularJS - Leaflet] The type of layer ' + layerDefinition.type + ' must have bounds defined');\n            return false ;\n        }\n\n        if (layerTypes[layerDefinition.type].mustHaveKey && !isDefined(layerDefinition.key)) {\n            $log.error('[AngularJS - Leaflet] The type of layer ' + layerDefinition.type + ' must have key defined');\n            return false ;\n        }\n        return true;\n    }\n\n    function createLayer(layerDefinition) {\n        if (!isValidLayerType(layerDefinition)) {\n            return;\n        }\n\n        if (!isString(layerDefinition.name)) {\n            $log.error('[AngularJS - Leaflet] A base layer must have a name');\n            return;\n        }\n        if (!isObject(layerDefinition.layerParams)) {\n            layerDefinition.layerParams = {};\n        }\n        if (!isObject(layerDefinition.layerOptions)) {\n            layerDefinition.layerOptions = {};\n        }\n\n        // Mix the layer specific parameters with the general Leaflet options. Although this is an overhead\n        // the definition of a base layers is more 'clean' if the two types of parameters are differentiated\n        for (var attrname in layerDefinition.layerParams) {\n            layerDefinition.layerOptions[attrname] = layerDefinition.layerParams[attrname];\n        }\n\n        var params = {\n            url: layerDefinition.url,\n            data: layerDefinition.data,\n            options: layerDefinition.layerOptions,\n            layer: layerDefinition.layer,\n            icon: layerDefinition.icon,\n            type: layerDefinition.layerType,\n            bounds: layerDefinition.bounds,\n            key: layerDefinition.key,\n            apiKey: layerDefinition.apiKey,\n            pluginOptions: layerDefinition.pluginOptions,\n            user: layerDefinition.user\n        };\n\n        //TODO Add $watch to the layer properties\n        return layerTypes[layerDefinition.type].createLayer(params);\n    }\n\n    function safeAddLayer(map, layer) {\n        if (layer && typeof layer.addTo === 'function') {\n            layer.addTo(map);\n        } else {\n            map.addLayer(layer);\n        }\n    }\n\n    function safeRemoveLayer(map, layer, layerOptions) {\n        if(isDefined(layerOptions) && isDefined(layerOptions.loadedDefer)) {\n            if(angular.isFunction(layerOptions.loadedDefer)) {\n                var defers = layerOptions.loadedDefer();\n                $log.debug('Loaded Deferred', defers);\n                var count = defers.length;\n                if(count > 0) {\n                    var resolve = function() {\n                        count--;\n                        if(count === 0) {\n                            map.removeLayer(layer);\n                        }\n                    };\n\n                    for(var i = 0; i < defers.length; i++) {\n                        defers[i].promise.then(resolve);\n                    }\n                } else {\n                    map.removeLayer(layer);\n                }\n            } else {\n                layerOptions.loadedDefer.promise.then(function() {\n                    map.removeLayer(layer);\n                });\n            }\n        } else {\n            map.removeLayer(layer);\n        }\n    }\n\n    return {\n        createLayer: createLayer,\n        safeAddLayer: safeAddLayer,\n        safeRemoveLayer: safeRemoveLayer\n    };\n}]);\n\nangular.module(\"leaflet-directive\").factory('leafletLegendHelpers', function () {\n\tvar _updateLegend = function(div, legendData, type, url) {\n\t\tdiv.innerHTML = '';\n\t\tif(legendData.error) {\n\t\t\tdiv.innerHTML += '<div class=\"info-title alert alert-danger\">' + legendData.error.message + '</div>';\n\t\t} else {\n\t\t\tif (type === 'arcgis') {\n\t\t\t\tfor (var i = 0; i < legendData.layers.length; i++) {\n\t\t\t\t\tvar layer = legendData.layers[i];\n\t\t\t\t\tdiv.innerHTML += '<div class=\"info-title\" data-layerid=\"' + layer.layerId + '\">' + layer.layerName + '</div>';\n\t\t\t\t\tfor(var j = 0; j < layer.legend.length; j++) {\n\t\t\t\t\t\tvar leg = layer.legend[j];\n\t\t\t\t\t\tdiv.innerHTML +=\n\t\t\t\t\t\t\t'<div class=\"inline\" data-layerid=\"' + layer.layerId + '\"><img src=\"data:' + leg.contentType + ';base64,' + leg.imageData + '\" /></div>' +\n\t\t\t\t\t\t\t'<div class=\"info-label\" data-layerid=\"' + layer.layerId + '\">' + leg.label + '</div>';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (type === 'image') {\n\t\t\t\tdiv.innerHTML = '<img src=\"' + url + '\"/>';\n\t\t\t}\n\t\t}\n\t};\n\n\tvar _getOnAddLegend = function(legendData, legendClass, type, url) {\n\t\treturn function(/*map*/) {\n\t\t\tvar div = L.DomUtil.create('div', legendClass);\n\n\t\t\tif (!L.Browser.touch) {\n\t\t\t\tL.DomEvent.disableClickPropagation(div);\n\t\t\t\tL.DomEvent.on(div, 'mousewheel', L.DomEvent.stopPropagation);\n\t\t\t} else {\n\t\t\t\tL.DomEvent.on(div, 'click', L.DomEvent.stopPropagation);\n\t\t\t}\n\t\t\t_updateLegend(div, legendData, type, url);\n\t\t\treturn div;\n\t\t};\n\t};\n\n\tvar _getOnAddArrayLegend = function(legend, legendClass) {\n\t\treturn function(/*map*/) {\n\t\t\tvar div = L.DomUtil.create('div', legendClass);\n            for (var i = 0; i < legend.colors.length; i++) {\n                div.innerHTML +=\n                    '<div class=\"outline\"><i style=\"background:' + legend.colors[i] + '\"></i></div>' +\n                    '<div class=\"info-label\">' + legend.labels[i] + '</div>';\n            }\n            if (!L.Browser.touch) {\n\t\t\t\tL.DomEvent.disableClickPropagation(div);\n\t\t\t\tL.DomEvent.on(div, 'mousewheel', L.DomEvent.stopPropagation);\n\t\t\t} else {\n\t\t\t\tL.DomEvent.on(div, 'click', L.DomEvent.stopPropagation);\n\t\t\t}\n            return div;\n\t\t};\n\t};\n\n\treturn {\n\t\tgetOnAddLegend: _getOnAddLegend,\n\t\tgetOnAddArrayLegend: _getOnAddArrayLegend,\n\t\tupdateLegend: _updateLegend\n\t};\n});\n\nangular.module(\"leaflet-directive\").factory('leafletMapDefaults', [\"$q\", \"leafletHelpers\", function ($q, leafletHelpers) {\n    function _getDefaults() {\n        return {\n            keyboard: true,\n            dragging: true,\n            worldCopyJump: false,\n            doubleClickZoom: true,\n            scrollWheelZoom: true,\n            tap: true,\n            touchZoom: true,\n            zoomControl: true,\n            zoomsliderControl: false,\n            zoomControlPosition: 'topleft',\n            attributionControl: true,\n            controls: {\n                layers: {\n                    visible: true,\n                    position: 'topright',\n                    collapsed: true\n                }\n            },\n            nominatim: {\n                server: ' http://nominatim.openstreetmap.org/search'\n            },\n            crs: L.CRS.EPSG3857,\n            tileLayer: '//{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',\n            tileLayerOptions: {\n                attribution: '&copy; <a href=\"http://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'\n            },\n            path: {\n                weight: 10,\n                opacity: 1,\n                color: '#0000ff'\n            },\n            center: {\n                lat: 0,\n                lng: 0,\n                zoom: 1\n            }\n        };\n    }\n\n    var isDefined = leafletHelpers.isDefined,\n        isObject = leafletHelpers.isObject,\n        obtainEffectiveMapId = leafletHelpers.obtainEffectiveMapId,\n        defaults = {};\n\n    // Get the _defaults dictionary, and override the properties defined by the user\n    return {\n        reset: function () {\n           defaults = {};\n        },\n        getDefaults: function (scopeId) {\n            var mapId = obtainEffectiveMapId(defaults, scopeId);\n            return defaults[mapId];\n        },\n\n        getMapCreationDefaults: function (scopeId) {\n            var mapId = obtainEffectiveMapId(defaults, scopeId);\n            var d = defaults[mapId];\n\n            var mapDefaults = {\n                maxZoom: d.maxZoom,\n                keyboard: d.keyboard,\n                dragging: d.dragging,\n                zoomControl: d.zoomControl,\n                doubleClickZoom: d.doubleClickZoom,\n                scrollWheelZoom: d.scrollWheelZoom,\n                tap: d.tap,\n                touchZoom: d.touchZoom,\n                attributionControl: d.attributionControl,\n                worldCopyJump: d.worldCopyJump,\n                crs: d.crs\n            };\n\n            if (isDefined(d.minZoom)) {\n                mapDefaults.minZoom = d.minZoom;\n            }\n\n            if (isDefined(d.zoomAnimation)) {\n                mapDefaults.zoomAnimation = d.zoomAnimation;\n            }\n\n            if (isDefined(d.fadeAnimation)) {\n                mapDefaults.fadeAnimation = d.fadeAnimation;\n            }\n\n            if (isDefined(d.markerZoomAnimation)) {\n                mapDefaults.markerZoomAnimation = d.markerZoomAnimation;\n            }\n\n            if (d.map) {\n                for (var option in d.map) {\n                    mapDefaults[option] = d.map[option];\n                }\n            }\n\n            return mapDefaults;\n        },\n\n        setDefaults: function (userDefaults, scopeId) {\n            var newDefaults = _getDefaults();\n\n            if (isDefined(userDefaults)) {\n                newDefaults.doubleClickZoom = isDefined(userDefaults.doubleClickZoom) ? userDefaults.doubleClickZoom : newDefaults.doubleClickZoom;\n                newDefaults.scrollWheelZoom = isDefined(userDefaults.scrollWheelZoom) ? userDefaults.scrollWheelZoom : newDefaults.doubleClickZoom;\n                newDefaults.tap = isDefined(userDefaults.tap) ? userDefaults.tap : newDefaults.tap;\n                newDefaults.touchZoom = isDefined(userDefaults.touchZoom) ? userDefaults.touchZoom : newDefaults.doubleClickZoom;\n                newDefaults.zoomControl = isDefined(userDefaults.zoomControl) ? userDefaults.zoomControl : newDefaults.zoomControl;\n                newDefaults.zoomsliderControl = isDefined(userDefaults.zoomsliderControl) ? userDefaults.zoomsliderControl : newDefaults.zoomsliderControl;\n                newDefaults.attributionControl = isDefined(userDefaults.attributionControl) ? userDefaults.attributionControl : newDefaults.attributionControl;\n                newDefaults.tileLayer = isDefined(userDefaults.tileLayer) ? userDefaults.tileLayer : newDefaults.tileLayer;\n                newDefaults.zoomControlPosition = isDefined(userDefaults.zoomControlPosition) ? userDefaults.zoomControlPosition : newDefaults.zoomControlPosition;\n                newDefaults.keyboard = isDefined(userDefaults.keyboard) ? userDefaults.keyboard : newDefaults.keyboard;\n                newDefaults.dragging = isDefined(userDefaults.dragging) ? userDefaults.dragging : newDefaults.dragging;\n\n                if (isDefined(userDefaults.controls)) {\n                    angular.extend(newDefaults.controls, userDefaults.controls);\n                }\n\n                if (isObject(userDefaults.crs)) {\n                    newDefaults.crs = userDefaults.crs;\n                } else if (isDefined(L.CRS[userDefaults.crs])) {\n                    newDefaults.crs = L.CRS[userDefaults.crs];\n                }\n\n                if (isDefined(userDefaults.center)) {\n                    angular.copy(userDefaults.center, newDefaults.center);\n                }\n\n                if (isDefined(userDefaults.tileLayerOptions)) {\n                    angular.copy(userDefaults.tileLayerOptions, newDefaults.tileLayerOptions);\n                }\n\n                if (isDefined(userDefaults.maxZoom)) {\n                    newDefaults.maxZoom = userDefaults.maxZoom;\n                }\n\n                if (isDefined(userDefaults.minZoom)) {\n                    newDefaults.minZoom = userDefaults.minZoom;\n                }\n\n                if (isDefined(userDefaults.zoomAnimation)) {\n                    newDefaults.zoomAnimation = userDefaults.zoomAnimation;\n                }\n\n                if (isDefined(userDefaults.fadeAnimation)) {\n                    newDefaults.fadeAnimation = userDefaults.fadeAnimation;\n                }\n\n                if (isDefined(userDefaults.markerZoomAnimation)) {\n                    newDefaults.markerZoomAnimation = userDefaults.markerZoomAnimation;\n                }\n\n                if (isDefined(userDefaults.worldCopyJump)) {\n                    newDefaults.worldCopyJump = userDefaults.worldCopyJump;\n                }\n\n                if (isDefined(userDefaults.map)) {\n                    newDefaults.map = userDefaults.map;\n                }\n\n                if (isDefined(userDefaults.path)) {\n                    newDefaults.path = userDefaults.path;\n                }\n            }\n\n            var mapId = obtainEffectiveMapId(defaults, scopeId);\n            defaults[mapId] = newDefaults;\n            return newDefaults;\n        }\n    };\n}]);\n\nangular.module(\"leaflet-directive\").service('leafletMarkersHelpers', [\"$rootScope\", \"$timeout\", \"leafletHelpers\", \"$log\", \"$compile\", \"leafletGeoJsonHelpers\", function ($rootScope, $timeout, leafletHelpers, $log, $compile, leafletGeoJsonHelpers) {\n    var isDefined = leafletHelpers.isDefined,\n        defaultTo = leafletHelpers.defaultTo,\n        MarkerClusterPlugin = leafletHelpers.MarkerClusterPlugin,\n        AwesomeMarkersPlugin = leafletHelpers.AwesomeMarkersPlugin,\n        VectorMarkersPlugin = leafletHelpers.VectorMarkersPlugin,\n        MakiMarkersPlugin = leafletHelpers.MakiMarkersPlugin,\n        ExtraMarkersPlugin = leafletHelpers.ExtraMarkersPlugin,\n        DomMarkersPlugin = leafletHelpers.DomMarkersPlugin,\n        safeApply = leafletHelpers.safeApply,\n        Helpers = leafletHelpers,\n        isString = leafletHelpers.isString,\n        isNumber = leafletHelpers.isNumber,\n        isObject = leafletHelpers.isObject,\n        groups = {},\n        geoHlp = leafletGeoJsonHelpers,\n        errorHeader = leafletHelpers.errorHeader;\n\n    var _string = function (marker) {\n        //this exists since JSON.stringify barfs on cyclic\n        var retStr = '';\n        ['_icon', '_latlng', '_leaflet_id', '_map', '_shadow'].forEach(function (prop) {\n            retStr += prop + ': ' + defaultTo(marker[prop], 'undefined') + ' \\n';\n        });\n        return '[leafletMarker] : \\n' + retStr;\n    };\n    var _log = function (marker, useConsole) {\n        var logger = useConsole ? console : $log;\n        logger.debug(_string(marker));\n    };\n\n    var createLeafletIcon = function (iconData) {\n        if (isDefined(iconData) && isDefined(iconData.type) && iconData.type === 'awesomeMarker') {\n            if (!AwesomeMarkersPlugin.isLoaded()) {\n                $log.error(errorHeader + ' The AwesomeMarkers Plugin is not loaded.');\n            }\n\n            return new L.AwesomeMarkers.icon(iconData);\n        }\n\n        if (isDefined(iconData) && isDefined(iconData.type) && iconData.type === 'vectorMarker') {\n            if (!VectorMarkersPlugin.isLoaded()) {\n                $log.error(errorHeader + ' The VectorMarkers Plugin is not loaded.');\n            }\n\n            return new L.VectorMarkers.icon(iconData);\n        }\n\n        if (isDefined(iconData) && isDefined(iconData.type) && iconData.type === 'makiMarker') {\n            if (!MakiMarkersPlugin.isLoaded()) {\n                $log.error(errorHeader + 'The MakiMarkers Plugin is not loaded.');\n            }\n\n            return new L.MakiMarkers.icon(iconData);\n        }\n\n        if (isDefined(iconData) && isDefined(iconData.type) && iconData.type === 'extraMarker') {\n            if (!ExtraMarkersPlugin.isLoaded()) {\n                $log.error(errorHeader + 'The ExtraMarkers Plugin is not loaded.');\n            }\n            return new L.ExtraMarkers.icon(iconData);\n        }\n\n        if (isDefined(iconData) && isDefined(iconData.type) && iconData.type === 'div') {\n            return new L.divIcon(iconData);\n        }\n\n        if (isDefined(iconData) && isDefined(iconData.type) && iconData.type === 'dom') {\n            if (!DomMarkersPlugin.isLoaded()) {\n                $log.error(errorHeader + 'The DomMarkers Plugin is not loaded.');\n            }\n            var markerScope = angular.isFunction(iconData.getMarkerScope) ? iconData.getMarkerScope() : $rootScope,\n                template = $compile(iconData.template)(markerScope),\n                iconDataCopy = angular.copy(iconData);\n            iconDataCopy.element = template[0];\n            return new L.DomMarkers.icon(iconDataCopy);\n        }\n\n        // allow for any custom icon to be used... assumes the icon has already been initialized\n        if (isDefined(iconData) && isDefined(iconData.type) && iconData.type === 'icon') {\n            return iconData.icon;\n        }\n\n        var base64icon = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAApCAYAAADAk4LOAAAGmklEQVRYw7VXeUyTZxjvNnfELFuyIzOabermMZEeQC/OclkO49CpOHXOLJl/CAURuYbQi3KLgEhbrhZ1aDwmaoGqKII6odATmH/scDFbdC7LvFqOCc+e95s2VG50X/LLm/f4/Z7neY/ne18aANCmAr5E/xZf1uDOkTcGcWR6hl9247tT5U7Y6SNvWsKT63P58qbfeLJG8M5qcgTknrvvrdDbsT7Ml+tv82X6vVxJE33aRmgSyYtcWVMqX97Yv2JvW39UhRE2HuyBL+t+gK1116ly06EeWFNlAmHxlQE0OMiV6mQCScusKRlhS3QLeVJdl1+23h5dY4FNB3thrbYboqptEFlphTC1hSpJnbRvxP4NWgsE5Jyz86QNNi/5qSUTGuFk1gu54tN9wuK2wc3o+Wc13RCmsoBwEqzGcZsxsvCSy/9wJKf7UWf1mEY8JWfewc67UUoDbDjQC+FqK4QqLVMGGR9d2wurKzqBk3nqIT/9zLxRRjgZ9bqQgub+DdoeCC03Q8j+0QhFhBHR/eP3U/zCln7Uu+hihJ1+bBNffLIvmkyP0gpBZWYXhKussK6mBz5HT6M1Nqpcp+mBCPXosYQfrekGvrjewd59/GvKCE7TbK/04/ZV5QZYVWmDwH1mF3xa2Q3ra3DBC5vBT1oP7PTj4C0+CcL8c7C2CtejqhuCnuIQHaKHzvcRfZpnylFfXsYJx3pNLwhKzRAwAhEqG0SpusBHfAKkxw3w4627MPhoCH798z7s0ZnBJ/MEJbZSbXPhER2ih7p2ok/zSj2cEJDd4CAe+5WYnBCgR2uruyEw6zRoW6/DWJ/OeAP8pd/BGtzOZKpG8oke0SX6GMmRk6GFlyAc59K32OTEinILRJRchah8HQwND8N435Z9Z0FY1EqtxUg+0SO6RJ/mmXz4VuS+DpxXC3gXmZwIL7dBSH4zKE50wESf8qwVgrP1EIlTO5JP9Igu0aexdh28F1lmAEGJGfh7jE6ElyM5Rw/FDcYJjWhbeiBYoYNIpc2FT/SILivp0F1ipDWk4BIEo2VuodEJUifhbiltnNBIXPUFCMpthtAyqws/BPlEF/VbaIxErdxPphsU7rcCp8DohC+GvBIPJS/tW2jtvTmmAeuNO8BNOYQeG8G/2OzCJ3q+soYB5i6NhMaKr17FSal7GIHheuV3uSCY8qYVuEm1cOzqdWr7ku/R0BDoTT+DT+ohCM6/CCvKLKO4RI+dXPeAuaMqksaKrZ7L3FE5FIFbkIceeOZ2OcHO6wIhTkNo0ffgjRGxEqogXHYUPHfWAC/lADpwGcLRY3aeK4/oRGCKYcZXPVoeX/kelVYY8dUGf8V5EBRbgJXT5QIPhP9ePJi428JKOiEYhYXFBqou2Guh+p/mEB1/RfMw6rY7cxcjTrneI1FrDyuzUSRm9miwEJx8E/gUmqlyvHGkneiwErR21F3tNOK5Tf0yXaT+O7DgCvALTUBXdM4YhC/IawPU+2PduqMvuaR6eoxSwUk75ggqsYJ7VicsnwGIkZBSXKOUww73WGXyqP+J2/b9c+gi1YAg/xpwck3gJuucNrh5JvDPvQr0WFXf0piyt8f8/WI0hV4pRxxkQZdJDfDJNOAmM0Ag8jyT6hz0WGXWuP94Yh2jcfjmXAGvHCMslRimDHYuHuDsy2QtHuIavznhbYURq5R57KpzBBRZKPJi8eQg48h4j8SDdowifdIrEVdU+gbO6QNvRRt4ZBthUaZhUnjlYObNagV3keoeru3rU7rcuceqU1mJBxy+BWZYlNEBH+0eH4vRiB+OYybU2hnblYlTvkHinM4m54YnxSyaZYSF6R3jwgP7udKLGIX6r/lbNa9N6y5MFynjWDtrHd75ZvTYAPO/6RgF0k76mQla3FGq7dO+cH8sKn0Vo7nDllwAhqwLPkxrHwWmHJOo+AKJ4rab5OgrM7rVu8eWb2Pu0Dh4eDgXoOfvp7Y7QeqknRmvcTBEyq9m/HQQSCSz6LHq3z0yzsNySRfMS253wl2KyRDbcZPcfJKjZmSEOjcxyi+Y8dUOtsIEH6R2wNykdqrkYJ0RV92H0W58pkfQk7cKevsLK10Py8SdMGfXNXATY+pPbyJR/ET6n9nIfztNtZYRV9XniQu9IA2vOVgy4ir7GCLVmmd+zjkH0eAF9Po6K61pmCXHxU5rHMYd1ftc3owjwRSVRzLjKvqZEty6cRUD7jGqiOdu5HG6MdHjNcNYGqfDm5YRzLBBCCDl/2bk8a8gdbqcfwECu62Fg/HrggAAAABJRU5ErkJggg==\";\n        var base64shadow = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACkAAAApCAYAAACoYAD2AAAC5ElEQVRYw+2YW4/TMBCF45S0S1luXZCABy5CgLQgwf//S4BYBLTdJLax0fFqmB07nnQfEGqkIydpVH85M+NLjPe++dcPc4Q8Qh4hj5D/AaQJx6H/4TMwB0PeBNwU7EGQAmAtsNfAzoZkgIa0ZgLMa4Aj6CxIAsjhjOCoL5z7Glg1JAOkaicgvQBXuncwJAWjksLtBTWZe04CnYRktUGdilALppZBOgHGZcBzL6OClABvMSVIzyBjazOgrvACf1ydC5mguqAVg6RhdkSWQFj2uxfaq/BrIZOLEWgZdALIDvcMcZLD8ZbLC9de4yR1sYMi4G20S4Q/PWeJYxTOZn5zJXANZHIxAd4JWhPIloTJZhzMQduM89WQ3MUVAE/RnhAXpTycqys3NZALOBbB7kFrgLesQl2h45Fcj8L1tTSohUwuxhy8H/Qg6K7gIs+3kkaigQCOcyEXCHN07wyQazhrmIulvKMQAwMcmLNqyCVyMAI+BuxSMeTk3OPikLY2J1uE+VHQk6ANrhds+tNARqBeaGc72cK550FP4WhXmFmcMGhTwAR1ifOe3EvPqIegFmF+C8gVy0OfAaWQPMR7gF1OQKqGoBjq90HPMP01BUjPOqGFksC4emE48tWQAH0YmvOgF3DST6xieJgHAWxPAHMuNhrImIdvoNOKNWIOcE+UXE0pYAnkX6uhWsgVXDxHdTfCmrEEmMB2zMFimLVOtiiajxiGWrbU52EeCdyOwPEQD8LqyPH9Ti2kgYMf4OhSKB7qYILbBv3CuVTJ11Y80oaseiMWOONc/Y7kJYe0xL2f0BaiFTxknHO5HaMGMublKwxFGzYdWsBF174H/QDknhTHmHHN39iWFnkZx8lPyM8WHfYELmlLKtgWNmFNzQcC1b47gJ4hL19i7o65dhH0Negbca8vONZoP7doIeOC9zXm8RjuL0Gf4d4OYaU5ljo3GYiqzrWQHfJxA6ALhDpVKv9qYeZA8eM3EhfPSCmpuD0AAAAASUVORK5CYII=\";\n\n        if (!isDefined(iconData) || !isDefined(iconData.iconUrl)) {\n            return new L.Icon.Default({\n                iconUrl: base64icon,\n                shadowUrl: base64shadow,\n                iconSize: [25, 41],\n                iconAnchor: [12, 41],\n                popupAnchor: [1, -34],\n                shadowSize: [41, 41]\n            });\n        }\n\n        return new L.Icon(iconData);\n    };\n\n    var _resetMarkerGroup = function (groupName) {\n        if (isDefined(groups[groupName])) {\n            groups.splice(groupName, 1);\n        }\n    };\n\n    var _resetMarkerGroups = function () {\n        groups = {};\n    };\n\n    var _deleteMarker = function (marker, map, layers) {\n        marker.closePopup();\n        // There is no easy way to know if a marker is added to a layer, so we search for it\n        // if there are overlays\n        if (isDefined(layers) && isDefined(layers.overlays)) {\n            for (var key in layers.overlays) {\n                if (layers.overlays[key] instanceof L.LayerGroup || layers.overlays[key] instanceof L.FeatureGroup) {\n                    if (layers.overlays[key].hasLayer(marker)) {\n                        layers.overlays[key].removeLayer(marker);\n                        return;\n                    }\n                }\n            }\n        }\n\n        if (isDefined(groups)) {\n            for (var groupKey in groups) {\n                if (groups[groupKey].hasLayer(marker)) {\n                    groups[groupKey].removeLayer(marker);\n                }\n            }\n        }\n\n        if (map.hasLayer(marker)) {\n            map.removeLayer(marker);\n        }\n    };\n\n    var adjustPopupPan = function(marker, map) {\n        var containerHeight = marker._popup._container.offsetHeight,\n            layerPos = new L.Point(marker._popup._containerLeft, -containerHeight - marker._popup._containerBottom),\n            containerPos = map.layerPointToContainerPoint(layerPos);\n        if (containerPos !== null) {\n            marker._popup._adjustPan();\n        }\n    };\n\n    var compilePopup = function(marker, markerScope) {\n        $compile(marker._popup._contentNode)(markerScope);\n    };\n\n    var updatePopup = function (marker, markerScope, map) {\n        //The innerText should be more than 1 once angular has compiled.\n        //We need to keep trying until angular has compiled before we _updateLayout and _updatePosition\n        //This should take care of any scenario , eg ngincludes, whatever.\n        //Is there a better way to check for this?\n        var innerText = marker._popup._contentNode.innerText || marker._popup._contentNode.textContent;\n        if (innerText.length < 1) {\n            $timeout(function () {\n                updatePopup(marker, markerScope, map);\n            });\n        }\n\n        //cause a reflow - this is also very important - if we don't do this then the widths are from before $compile\n        var reflow = marker._popup._contentNode.offsetWidth;\n\n        marker._popup._updateLayout();\n        marker._popup._updatePosition();\n\n        if (marker._popup.options.autoPan) {\n            adjustPopupPan(marker, map);\n        }\n\n        //using / returning reflow so jshint doesn't moan\n        return reflow;\n    };\n\n    var _manageOpenPopup = function (marker, markerData, map) {\n        // The marker may provide a scope returning function used to compile the message\n        // default to $rootScope otherwise\n        var markerScope = angular.isFunction(markerData.getMessageScope) ? markerData.getMessageScope() : $rootScope,\n            compileMessage = isDefined(markerData.compileMessage) ? markerData.compileMessage : true;\n\n        if (compileMessage) {\n            if (!isDefined(marker._popup) || !isDefined(marker._popup._contentNode)) {\n                $log.error(errorHeader + 'Popup is invalid or does not have any content.');\n                return false;\n            }\n\n            compilePopup(marker, markerScope);\n            updatePopup(marker, markerData, map);\n        }\n    };\n\n\n    var _manageOpenLabel = function (marker, markerData) {\n        var markerScope = angular.isFunction(markerData.getMessageScope) ? markerData.getMessageScope() : $rootScope,\n            labelScope = angular.isFunction(markerData.getLabelScope) ? markerData.getLabelScope() : markerScope,\n            compileMessage = isDefined(markerData.compileMessage) ? markerData.compileMessage : true;\n\n        if (Helpers.LabelPlugin.isLoaded() && isDefined(markerData.label)) {\n            if (isDefined(markerData.label.options) && markerData.label.options.noHide === true) {\n                marker.showLabel();\n            }\n            if (compileMessage && isDefined(marker.label)) {\n                $compile(marker.label._container)(labelScope);\n            }\n        }\n    };\n\n    var _updateMarker = function (markerData, oldMarkerData, marker, name, leafletScope, layers, map) {\n            if (!isDefined(oldMarkerData)) {\n                return;\n            }\n\n            // Update the lat-lng property (always present in marker properties)\n            if (!geoHlp.validateCoords(markerData)) {\n                $log.warn('There are problems with lat-lng data, please verify your marker model');\n                _deleteMarker(marker, map, layers);\n                return;\n            }\n\n            // watch is being initialized if old and new object is the same\n            var isInitializing = markerData === oldMarkerData;\n\n            // Update marker rotation\n            if (isDefined(markerData.iconAngle) && oldMarkerData.iconAngle !== markerData.iconAngle) {\n                marker.setIconAngle(markerData.iconAngle);\n            }\n\n            // It is possible that the layer has been removed or the layer marker does not exist\n            // Update the layer group if present or move it to the map if not\n            if (!isString(markerData.layer)) {\n                // There is no layer information, we move the marker to the map if it was in a layer group\n                if (isString(oldMarkerData.layer)) {\n                    // Remove from the layer group that is supposed to be\n                    if (isDefined(layers.overlays[oldMarkerData.layer]) && layers.overlays[oldMarkerData.layer].hasLayer(marker)) {\n                        layers.overlays[oldMarkerData.layer].removeLayer(marker);\n                        marker.closePopup();\n                    }\n                    // Test if it is not on the map and add it\n                    if (!map.hasLayer(marker)) {\n                        map.addLayer(marker);\n                    }\n                }\n            }\n\n            if ((isNumber(markerData.opacity) || isNumber(parseFloat(markerData.opacity))) && markerData.opacity !== oldMarkerData.opacity) {\n                // There was a different opacity so we update it\n                marker.setOpacity(markerData.opacity);\n            }\n\n            if (isString(markerData.layer) && oldMarkerData.layer !== markerData.layer) {\n                // If it was on a layer group we have to remove it\n                if (isString(oldMarkerData.layer) && isDefined(layers.overlays[oldMarkerData.layer]) && layers.overlays[oldMarkerData.layer].hasLayer(marker)) {\n                    layers.overlays[oldMarkerData.layer].removeLayer(marker);\n                }\n                marker.closePopup();\n\n                // Remove it from the map in case the new layer is hidden or there is an error in the new layer\n                if (map.hasLayer(marker)) {\n                    map.removeLayer(marker);\n                }\n\n                // The markerData.layer is defined so we add the marker to the layer if it is different from the old data\n                if (!isDefined(layers.overlays[markerData.layer])) {\n                    $log.error(errorHeader + 'You must use a name of an existing layer');\n                    return;\n                }\n                // Is a group layer?\n                var layerGroup = layers.overlays[markerData.layer];\n                if (!(layerGroup instanceof L.LayerGroup || layerGroup instanceof L.FeatureGroup)) {\n                    $log.error(errorHeader + 'A marker can only be added to a layer of type \"group\" or \"featureGroup\"');\n                    return;\n                }\n                // The marker goes to a correct layer group, so first of all we add it\n                layerGroup.addLayer(marker);\n                // The marker is automatically added to the map depending on the visibility\n                // of the layer, so we only have to open the popup if the marker is in the map\n                if (map.hasLayer(marker) && markerData.focus === true) {\n                    marker.openPopup();\n                }\n            }\n\n            // Update the draggable property\n            if (markerData.draggable !== true && oldMarkerData.draggable === true && (isDefined(marker.dragging))) {\n                marker.dragging.disable();\n            }\n\n            if (markerData.draggable === true && oldMarkerData.draggable !== true) {\n                // The markerData.draggable property must be true so we update if there wasn't a previous value or it wasn't true\n                if (marker.dragging) {\n                    marker.dragging.enable();\n                } else {\n                    if (L.Handler.MarkerDrag) {\n                        marker.dragging = new L.Handler.MarkerDrag(marker);\n                        marker.options.draggable = true;\n                        marker.dragging.enable();\n                    }\n                }\n            }\n\n            // Update the icon property\n            if (!isObject(markerData.icon)) {\n                // If there is no icon property or it's not an object\n                if (isObject(oldMarkerData.icon)) {\n                    // If there was an icon before restore to the default\n                    marker.setIcon(createLeafletIcon());\n                    marker.closePopup();\n                    marker.unbindPopup();\n                    if (isString(markerData.message)) {\n                        marker.bindPopup(markerData.message, markerData.popupOptions);\n                    }\n                }\n            }\n\n            if (isObject(markerData.icon) && isObject(oldMarkerData.icon) && !angular.equals(markerData.icon, oldMarkerData.icon)) {\n                var dragG = false;\n                if (marker.dragging) {\n                    dragG = marker.dragging.enabled();\n                }\n                marker.setIcon(createLeafletIcon(markerData.icon));\n                if (dragG) {\n                    marker.dragging.enable();\n                }\n                marker.closePopup();\n                marker.unbindPopup();\n                if (isString(markerData.message)) {\n                    marker.bindPopup(markerData.message, markerData.popupOptions);\n                    // if marker has been already focused, reopen popup\n                    if (map.hasLayer(marker) && markerData.focus === true) {\n                        marker.openPopup();\n                    }\n                }\n            }\n\n            // Update the Popup message property\n            if (!isString(markerData.message) && isString(oldMarkerData.message)) {\n                marker.closePopup();\n                marker.unbindPopup();\n            }\n\n            // Update the label content or bind a new label if the old one has been removed.\n            if (Helpers.LabelPlugin.isLoaded()) {\n                if (isDefined(markerData.label) && isDefined(markerData.label.message)) {\n                    if ('label' in oldMarkerData && 'message' in oldMarkerData.label && !angular.equals(markerData.label.message, oldMarkerData.label.message)) {\n                        marker.updateLabelContent(markerData.label.message);\n                    } else if (!angular.isFunction(marker.getLabel) || angular.isFunction(marker.getLabel) && !isDefined(marker.getLabel())) {\n                        marker.bindLabel(markerData.label.message, markerData.label.options);\n                        _manageOpenLabel(marker, markerData);\n                    } else {\n                        _manageOpenLabel(marker, markerData);\n                    }\n                } else if (!('label' in markerData && !('message' in markerData.label))) {\n                    if (angular.isFunction(marker.unbindLabel)) {\n                        marker.unbindLabel();\n                    }\n                }\n            }\n\n            // There is some text in the popup, so we must show the text or update existing\n            if (isString(markerData.message) && !isString(oldMarkerData.message)) {\n                // There was no message before so we create it\n                marker.bindPopup(markerData.message, markerData.popupOptions);\n            }\n\n            if (isString(markerData.message) && isString(oldMarkerData.message) && markerData.message !== oldMarkerData.message) {\n                // There was a different previous message so we update it\n                marker.setPopupContent(markerData.message);\n            }\n\n            // Update the focus property\n            var updatedFocus = false;\n            if (markerData.focus !== true && oldMarkerData.focus === true) {\n                // If there was a focus property and was true we turn it off\n                marker.closePopup();\n                updatedFocus = true;\n            }\n\n            // The markerData.focus property must be true so we update if there wasn't a previous value or it wasn't true\n            if (markerData.focus === true && ( !isDefined(oldMarkerData.focus) || oldMarkerData.focus === false) || (isInitializing && markerData.focus === true)) {\n                // Reopen the popup when focus is still true\n                marker.openPopup();\n                updatedFocus = true;\n            }\n\n            // zIndexOffset adjustment\n            if (oldMarkerData.zIndexOffset !== markerData.zIndexOffset) {\n                marker.setZIndexOffset(markerData.zIndexOffset);\n            }\n\n            var markerLatLng = marker.getLatLng();\n            var isCluster = (isString(markerData.layer) && Helpers.MarkerClusterPlugin.is(layers.overlays[markerData.layer]));\n            // If the marker is in a cluster it has to be removed and added to the layer when the location is changed\n            if (isCluster) {\n                // The focus has changed even by a user click or programatically\n                if (updatedFocus) {\n                    // We only have to update the location if it was changed programatically, because it was\n                    // changed by a user drag the marker data has already been updated by the internal event\n                    // listened by the directive\n                    if ((markerData.lat !== oldMarkerData.lat) || (markerData.lng !== oldMarkerData.lng)) {\n                        layers.overlays[markerData.layer].removeLayer(marker);\n                        marker.setLatLng([markerData.lat, markerData.lng]);\n                        layers.overlays[markerData.layer].addLayer(marker);\n                    }\n                } else {\n                    // The marker has possibly moved. It can be moved by a user drag (marker location and data are equal but old\n                    // data is diferent) or programatically (marker location and data are diferent)\n                    if ((markerLatLng.lat !== markerData.lat) || (markerLatLng.lng !== markerData.lng)) {\n                        // The marker was moved by a user drag\n                        layers.overlays[markerData.layer].removeLayer(marker);\n                        marker.setLatLng([markerData.lat, markerData.lng]);\n                        layers.overlays[markerData.layer].addLayer(marker);\n                    } else if ((markerData.lat !== oldMarkerData.lat) || (markerData.lng !== oldMarkerData.lng)) {\n                        // The marker was moved programatically\n                        layers.overlays[markerData.layer].removeLayer(marker);\n                        marker.setLatLng([markerData.lat, markerData.lng]);\n                        layers.overlays[markerData.layer].addLayer(marker);\n                    } else if (isObject(markerData.icon) && isObject(oldMarkerData.icon) && !angular.equals(markerData.icon, oldMarkerData.icon)) {\n                        layers.overlays[markerData.layer].removeLayer(marker);\n                        layers.overlays[markerData.layer].addLayer(marker);\n                    }\n                }\n            } else if (markerLatLng.lat !== markerData.lat || markerLatLng.lng !== markerData.lng) {\n                marker.setLatLng([markerData.lat, markerData.lng]);\n            }\n        };\n    return {\n        resetMarkerGroup: _resetMarkerGroup,\n\n        resetMarkerGroups: _resetMarkerGroups,\n\n        deleteMarker: _deleteMarker,\n\n        manageOpenPopup: _manageOpenPopup,\n\n        manageOpenLabel: _manageOpenLabel,\n\n        createMarker: function (markerData) {\n            if (!isDefined(markerData) || !geoHlp.validateCoords(markerData)) {\n                $log.error(errorHeader + 'The marker definition is not valid.');\n                return;\n            }\n            var coords = geoHlp.getCoords(markerData);\n\n            if (!isDefined(coords)) {\n                $log.error(errorHeader + 'Unable to get coordinates from markerData.');\n                return;\n            }\n\n            var markerOptions = {\n                icon: createLeafletIcon(markerData.icon),\n                title: isDefined(markerData.title) ? markerData.title : '',\n                draggable: isDefined(markerData.draggable) ? markerData.draggable : false,\n                clickable: isDefined(markerData.clickable) ? markerData.clickable : true,\n                riseOnHover: isDefined(markerData.riseOnHover) ? markerData.riseOnHover : false,\n                zIndexOffset: isDefined(markerData.zIndexOffset) ? markerData.zIndexOffset : 0,\n                iconAngle: isDefined(markerData.iconAngle) ? markerData.iconAngle : 0\n            };\n            // Add any other options not added above to markerOptions\n            for (var markerDatum in markerData) {\n                if (markerData.hasOwnProperty(markerDatum) && !markerOptions.hasOwnProperty(markerDatum)) {\n                    markerOptions[markerDatum] = markerData[markerDatum];\n                }\n            }\n\n            var marker = new L.marker(coords, markerOptions);\n\n            if (!isString(markerData.message)) {\n                marker.unbindPopup();\n            }\n\n            return marker;\n        },\n\n        addMarkerToGroup: function (marker, groupName, groupOptions, map) {\n            if (!isString(groupName)) {\n                $log.error(errorHeader + 'The marker group you have specified is invalid.');\n                return;\n            }\n\n            if (!MarkerClusterPlugin.isLoaded()) {\n                $log.error(errorHeader + \"The MarkerCluster plugin is not loaded.\");\n                return;\n            }\n            if (!isDefined(groups[groupName])) {\n                groups[groupName] = new L.MarkerClusterGroup(groupOptions);\n                map.addLayer(groups[groupName]);\n            }\n            groups[groupName].addLayer(marker);\n        },\n\n        listenMarkerEvents: function (marker, markerData, leafletScope, doWatch, map) {\n            marker.on(\"popupopen\", function (/* event */) {\n                safeApply(leafletScope, function () {\n                    if (isDefined(marker._popup) || isDefined(marker._popup._contentNode)) {\n                        markerData.focus = true;\n                        _manageOpenPopup(marker, markerData, map);//needed since markerData is now a copy\n                    }\n                });\n            });\n            marker.on(\"popupclose\", function (/* event */) {\n                safeApply(leafletScope, function () {\n                    markerData.focus = false;\n                });\n            });\n            marker.on(\"add\", function (/* event */) {\n                safeApply(leafletScope, function () {\n                    if ('label' in markerData)\n                        _manageOpenLabel(marker, markerData);\n                });\n            });\n        },\n\n        updateMarker: _updateMarker,\n\n        addMarkerWatcher: function (marker, name, leafletScope, layers, map, isDeepWatch) {\n            var markerWatchPath = Helpers.getObjectArrayPath(\"markers.\" + name);\n            isDeepWatch = defaultTo(isDeepWatch, true);\n\n            var clearWatch = leafletScope.$watch(markerWatchPath, function(markerData, oldMarkerData) {\n                if (!isDefined(markerData)) {\n                    _deleteMarker(marker, map, layers);\n                    clearWatch();\n                    return;\n                }\n                _updateMarker(markerData, oldMarkerData, marker, name, leafletScope, layers, map);\n            } , isDeepWatch);\n        },\n        string: _string,\n        log: _log\n    };\n}]);\n\nangular.module(\"leaflet-directive\").factory('leafletPathsHelpers', [\"$rootScope\", \"$log\", \"leafletHelpers\", function ($rootScope, $log, leafletHelpers) {\n    var isDefined = leafletHelpers.isDefined,\n        isArray = leafletHelpers.isArray,\n        isNumber = leafletHelpers.isNumber,\n        isValidPoint = leafletHelpers.isValidPoint;\n\n    var availableOptions = [\n        // Path options\n        'stroke', 'weight', 'color', 'opacity',\n        'fill', 'fillColor', 'fillOpacity',\n        'dashArray', 'lineCap', 'lineJoin', 'clickable',\n        'pointerEvents', 'className',\n\n        // Polyline options\n        'smoothFactor', 'noClip'\n    ];\n    function _convertToLeafletLatLngs(latlngs) {\n        return latlngs.filter(function(latlng) {\n            return isValidPoint(latlng);\n        }).map(function (latlng) {\n            return _convertToLeafletLatLng(latlng);\n        });\n    }\n\n    function _convertToLeafletLatLng(latlng) {\n        if (isArray(latlng)) {\n            return new L.LatLng(latlng[0], latlng[1]);\n        } else {\n            return new L.LatLng(latlng.lat, latlng.lng);\n        }\n    }\n\n    function _convertToLeafletMultiLatLngs(paths) {\n        return paths.map(function(latlngs) {\n            return _convertToLeafletLatLngs(latlngs);\n        });\n    }\n\n    function _getOptions(path, defaults) {\n        var options = {};\n        for (var i = 0; i < availableOptions.length; i++) {\n            var optionName = availableOptions[i];\n\n            if (isDefined(path[optionName])) {\n                options[optionName] = path[optionName];\n            } else if (isDefined(defaults.path[optionName])) {\n                options[optionName] = defaults.path[optionName];\n            }\n        }\n\n        return options;\n    }\n\n    var _updatePathOptions = function (path, data) {\n        var updatedStyle = {};\n        for (var i = 0; i < availableOptions.length; i++) {\n            var optionName = availableOptions[i];\n            if (isDefined(data[optionName])) {\n                updatedStyle[optionName] = data[optionName];\n            }\n        }\n        path.setStyle(data);\n    };\n\n    var _isValidPolyline = function(latlngs) {\n        if (!isArray(latlngs)) {\n            return false;\n        }\n        for (var i = 0; i < latlngs.length; i++) {\n            var point = latlngs[i];\n            if (!isValidPoint(point)) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    var pathTypes = {\n        polyline: {\n            isValid: function(pathData) {\n                var latlngs = pathData.latlngs;\n                return _isValidPolyline(latlngs);\n            },\n            createPath: function(options) {\n                return new L.Polyline([], options);\n            },\n            setPath: function(path, data) {\n                path.setLatLngs(_convertToLeafletLatLngs(data.latlngs));\n                _updatePathOptions(path, data);\n                return;\n            }\n        },\n        multiPolyline: {\n            isValid: function(pathData) {\n                var latlngs = pathData.latlngs;\n                if (!isArray(latlngs)) {\n                    return false;\n                }\n\n                for (var i in latlngs) {\n                    var polyline = latlngs[i];\n                    if (!_isValidPolyline(polyline)) {\n                        return false;\n                    }\n                }\n\n                return true;\n            },\n            createPath: function(options) {\n                return new L.multiPolyline([[[0,0],[1,1]]], options);\n            },\n            setPath: function(path, data) {\n                path.setLatLngs(_convertToLeafletMultiLatLngs(data.latlngs));\n                _updatePathOptions(path, data);\n                return;\n            }\n        } ,\n        polygon: {\n            isValid: function(pathData) {\n                var latlngs = pathData.latlngs;\n                return _isValidPolyline(latlngs);\n            },\n            createPath: function(options) {\n                return new L.Polygon([], options);\n            },\n            setPath: function(path, data) {\n                path.setLatLngs(_convertToLeafletLatLngs(data.latlngs));\n                _updatePathOptions(path, data);\n                return;\n            }\n        },\n        multiPolygon: {\n            isValid: function(pathData) {\n                var latlngs = pathData.latlngs;\n\n                if (!isArray(latlngs)) {\n                    return false;\n                }\n\n                for (var i in latlngs) {\n                    var polyline = latlngs[i];\n                    if (!_isValidPolyline(polyline)) {\n                        return false;\n                    }\n                }\n\n                return true;\n            },\n            createPath: function(options) {\n                return new L.MultiPolygon([[[0,0],[1,1],[0,1]]], options);\n            },\n            setPath: function(path, data) {\n                path.setLatLngs(_convertToLeafletMultiLatLngs(data.latlngs));\n                _updatePathOptions(path, data);\n                return;\n            }\n        },\n        rectangle: {\n            isValid: function(pathData) {\n                var latlngs = pathData.latlngs;\n\n                if (!isArray(latlngs) || latlngs.length !== 2) {\n                    return false;\n                }\n\n                for (var i in latlngs) {\n                    var point = latlngs[i];\n                    if (!isValidPoint(point)) {\n                        return false;\n                    }\n                }\n\n                return true;\n            },\n            createPath: function(options) {\n                return new L.Rectangle([[0,0],[1,1]], options);\n            },\n            setPath: function(path, data) {\n                path.setBounds(new L.LatLngBounds(_convertToLeafletLatLngs(data.latlngs)));\n                _updatePathOptions(path, data);\n            }\n        },\n        circle: {\n            isValid: function(pathData) {\n                var point= pathData.latlngs;\n                return isValidPoint(point) && isNumber(pathData.radius);\n            },\n            createPath: function(options) {\n                return new L.Circle([0,0], 1, options);\n            },\n            setPath: function(path, data) {\n                path.setLatLng(_convertToLeafletLatLng(data.latlngs));\n                if (isDefined(data.radius)) {\n                    path.setRadius(data.radius);\n                }\n                _updatePathOptions(path, data);\n            }\n        },\n        circleMarker: {\n            isValid: function(pathData) {\n                var point= pathData.latlngs;\n                return isValidPoint(point) && isNumber(pathData.radius);\n            },\n            createPath: function(options) {\n                return new L.CircleMarker([0,0], options);\n            },\n            setPath: function(path, data) {\n                path.setLatLng(_convertToLeafletLatLng(data.latlngs));\n                if (isDefined(data.radius)) {\n                    path.setRadius(data.radius);\n                }\n                _updatePathOptions(path, data);\n            }\n        }\n    };\n\n    var _getPathData = function(path) {\n        var pathData = {};\n        if (path.latlngs) {\n            pathData.latlngs = path.latlngs;\n        }\n\n        if (path.radius) {\n            pathData.radius = path.radius;\n        }\n\n        return pathData;\n    };\n\n    return {\n        setPathOptions: function(leafletPath, pathType, data) {\n            if(!isDefined(pathType)) {\n                pathType = \"polyline\";\n            }\n            pathTypes[pathType].setPath(leafletPath, data);\n        },\n        createPath: function(name, path, defaults) {\n            if(!isDefined(path.type)) {\n                path.type = \"polyline\";\n            }\n            var options = _getOptions(path, defaults);\n            var pathData = _getPathData(path);\n\n            if (!pathTypes[path.type].isValid(pathData)) {\n                $log.error(\"[AngularJS - Leaflet] Invalid data passed to the \" + path.type + \" path\");\n                return;\n            }\n\n            return pathTypes[path.type].createPath(options);\n        }\n    };\n}]);\n\nangular.module(\"leaflet-directive\")\n.service('leafletWatchHelpers', function (){\n\n    var _maybe = function(scope, watchFunctionName, thingToWatchStr, watchOptions, initCb){\n        //watchOptions.isDeep is/should be ignored in $watchCollection\n        var unWatch = scope[watchFunctionName](thingToWatchStr, function(newValue, oldValue) {\n            initCb(newValue, oldValue);\n            if(!watchOptions.doWatch)\n                unWatch();\n        }, watchOptions.isDeep);\n\n        return unWatch;\n    };\n\n  /*\n  @name: maybeWatch\n  @description: Utility to watch something once or forever.\n  @returns unWatch function\n  @param watchOptions - see markersWatchOptions and or derrivatives. This object is used\n  to set watching to once and its watch depth.\n  */\n  var _maybeWatch = function(scope, thingToWatchStr, watchOptions, initCb){\n      return _maybe(scope, '$watch', thingToWatchStr, watchOptions, initCb);\n  };\n\n  /*\n  @name: _maybeWatchCollection\n  @description: Utility to watch something once or forever.\n  @returns unWatch function\n  @param watchOptions - see markersWatchOptions and or derrivatives. This object is used\n  to set watching to once and its watch depth.\n  */\n  var _maybeWatchCollection = function(scope, thingToWatchStr, watchOptions, initCb){\n      return _maybe(scope, '$watchCollection', thingToWatchStr, watchOptions, initCb);\n  };\n\n  return {\n    maybeWatch: _maybeWatch,\n    maybeWatchCollection: _maybeWatchCollection\n  };\n});\n\nangular.module(\"leaflet-directive\").factory('nominatimService', [\"$q\", \"$http\", \"leafletHelpers\", \"leafletMapDefaults\", function ($q, $http, leafletHelpers, leafletMapDefaults) {\n    var isDefined = leafletHelpers.isDefined;\n\n    return {\n        query: function(address, mapId) {\n            var defaults = leafletMapDefaults.getDefaults(mapId);\n            var url = defaults.nominatim.server;\n            var df = $q.defer();\n\n            $http.get(url, { params: { format: 'json', limit: 1, q: address } }).success(function(data) {\n                if (data.length > 0 && isDefined(data[0].boundingbox)) {\n                    df.resolve(data[0]);\n                } else {\n                    df.reject('[Nominatim] Invalid address');\n                }\n            });\n\n            return df.promise;\n        }\n    };\n}]);\n\nangular.module(\"leaflet-directive\").directive('bounds', [\"$log\", \"$timeout\", \"$http\", \"leafletHelpers\", \"nominatimService\", \"leafletBoundsHelpers\", function ($log, $timeout, $http, leafletHelpers, nominatimService, leafletBoundsHelpers) {\n\n    return {\n        restrict: \"A\",\n        scope: false,\n        replace: false,\n        require: [ 'leaflet' ],\n\n        link: function(scope, element, attrs, controller) {\n            var isDefined = leafletHelpers.isDefined;\n            var createLeafletBounds = leafletBoundsHelpers.createLeafletBounds;\n            var leafletScope = controller[0].getLeafletScope();\n            var mapController = controller[0];\n            var errorHeader = leafletHelpers.errorHeader + ' [Bounds] ';\n\n            var emptyBounds = function(bounds) {\n                return (bounds._southWest.lat === 0 && bounds._southWest.lng === 0 &&\n                        bounds._northEast.lat === 0 && bounds._northEast.lng === 0);\n            };\n\n            mapController.getMap().then(function (map) {\n                leafletScope.$on('boundsChanged', function (event) {\n                    var scope = event.currentScope;\n                    var bounds = map.getBounds();\n\n                    if (emptyBounds(bounds) || scope.settingBoundsFromScope) {\n                        return;\n                    }\n                    scope.settingBoundsFromLeaflet = true;\n                    var newScopeBounds = {\n                        northEast: {\n                            lat: bounds._northEast.lat,\n                            lng: bounds._northEast.lng\n                        },\n                        southWest: {\n                            lat: bounds._southWest.lat,\n                            lng: bounds._southWest.lng\n                        },\n                        options: bounds.options\n                    };\n                    if (!angular.equals(scope.bounds, newScopeBounds)) {\n                        scope.bounds = newScopeBounds;\n                    }\n                    $timeout( function() {\n                        scope.settingBoundsFromLeaflet = false;\n                    });\n                });\n\n                var lastNominatimQuery;\n                leafletScope.$watch('bounds', function (bounds) {\n                    if (scope.settingBoundsFromLeaflet)\n                        return;\n                    if (isDefined(bounds.address) && bounds.address !== lastNominatimQuery) {\n                        scope.settingBoundsFromScope = true;\n                        nominatimService.query(bounds.address, attrs.id).then(function(data) {\n                            var b = data.boundingbox;\n                            var newBounds = [ [ b[0], b[2]], [ b[1], b[3]] ];\n                            map.fitBounds(newBounds);\n                        }, function(errMsg) {\n                            $log.error(errorHeader + ' ' + errMsg + '.');\n                        });\n                        lastNominatimQuery = bounds.address;\n                        $timeout( function() {\n                            scope.settingBoundsFromScope = false;\n                        });\n                        return;\n                    }\n\n                    var leafletBounds = createLeafletBounds(bounds);\n                    if (leafletBounds && !map.getBounds().equals(leafletBounds)) {\n                        scope.settingBoundsFromScope = true;\n                        map.fitBounds(leafletBounds, bounds.options);\n                        $timeout( function() {\n                            scope.settingBoundsFromScope = false;\n                        });\n                    }\n                }, true);\n            });\n        }\n    };\n}]);\n\nvar centerDirectiveTypes = ['center', 'lfCenter'],\n    centerDirectives = {};\n\ncenterDirectiveTypes.forEach(function(directiveName) {\n    centerDirectives[directiveName] = [ '$log', '$q', '$location', '$timeout', 'leafletMapDefaults', 'leafletHelpers',\n        'leafletBoundsHelpers', 'leafletMapEvents',\n        function($log, $q, $location, $timeout, leafletMapDefaults, leafletHelpers,\n      leafletBoundsHelpers, leafletMapEvents) {\n\n        var isDefined = leafletHelpers.isDefined,\n            isNumber = leafletHelpers.isNumber,\n            isSameCenterOnMap = leafletHelpers.isSameCenterOnMap,\n            safeApply = leafletHelpers.safeApply,\n            isValidCenter = leafletHelpers.isValidCenter,\n            isValidBounds = leafletBoundsHelpers.isValidBounds,\n            isUndefinedOrEmpty = leafletHelpers.isUndefinedOrEmpty,\n            errorHeader = leafletHelpers.errorHeader;\n\n        var shouldInitializeMapWithBounds = function(bounds, center) {\n            return isDefined(bounds) && isValidBounds(bounds) && isUndefinedOrEmpty(center);\n        };\n\n        var _leafletCenter;\n        return {\n            restrict: \"A\",\n            scope: false,\n            replace: false,\n            require: 'leaflet',\n            controller: function() {\n                _leafletCenter = $q.defer();\n                this.getCenter = function() {\n                    return _leafletCenter.promise;\n                };\n            },\n            link: function(scope, element, attrs, controller) {\n                var leafletScope = controller.getLeafletScope(),\n                    centerModel = leafletScope[directiveName];\n\n                controller.getMap().then(function(map) {\n                    var defaults = leafletMapDefaults.getDefaults(attrs.id);\n\n                    if (attrs[directiveName].search(\"-\") !== -1) {\n                        $log.error(errorHeader + ' The \"center\" variable can\\'t use a \"-\" on its key name: \"' + attrs[directiveName] + '\".');\n                        map.setView([defaults.center.lat, defaults.center.lng], defaults.center.zoom);\n                        return;\n                    } else if (shouldInitializeMapWithBounds(leafletScope.bounds, centerModel)) {\n                        map.fitBounds(leafletBoundsHelpers.createLeafletBounds(leafletScope.bounds), leafletScope.bounds.options);\n                        centerModel = map.getCenter();\n                        safeApply(leafletScope, function(scope) {\n                            angular.extend(scope[directiveName], {\n                                lat: map.getCenter().lat,\n                                lng: map.getCenter().lng,\n                                zoom: map.getZoom(),\n                                autoDiscover: false\n                            });\n                        });\n                        safeApply(leafletScope, function(scope) {\n                            var mapBounds = map.getBounds();\n                            scope.bounds = {\n                                northEast: {\n                                    lat: mapBounds._northEast.lat,\n                                    lng: mapBounds._northEast.lng\n                                },\n                                southWest: {\n                                    lat: mapBounds._southWest.lat,\n                                    lng: mapBounds._southWest.lng\n                                }\n                            };\n                        });\n                    } else if (!isDefined(centerModel)) {\n                        $log.error(errorHeader + ' The \"center\" property is not defined in the main scope');\n                        map.setView([defaults.center.lat, defaults.center.lng], defaults.center.zoom);\n                        return;\n                    } else if (!(isDefined(centerModel.lat) && isDefined(centerModel.lng)) && !isDefined(centerModel.autoDiscover)) {\n                        angular.copy(defaults.center, centerModel);\n                    }\n\n                    var urlCenterHash, mapReady;\n                    if (attrs.urlHashCenter === \"yes\") {\n                        var extractCenterFromUrl = function() {\n                            var search = $location.search();\n                            var centerParam;\n                            if (isDefined(search.c)) {\n                                var cParam = search.c.split(\":\");\n                                if (cParam.length === 3) {\n                                    centerParam = {\n                                        lat: parseFloat(cParam[0]),\n                                        lng: parseFloat(cParam[1]),\n                                        zoom: parseInt(cParam[2], 10)\n                                    };\n                                }\n                            }\n                            return centerParam;\n                        };\n                        urlCenterHash = extractCenterFromUrl();\n\n                        leafletScope.$on('$locationChangeSuccess', function(event) {\n                            var scope = event.currentScope;\n                            //$log.debug(\"updated location...\");\n                            var urlCenter = extractCenterFromUrl();\n                            if (isDefined(urlCenter) && !isSameCenterOnMap(urlCenter, map)) {\n                                //$log.debug(\"updating center model...\", urlCenter);\n                                angular.extend(scope[directiveName], {\n                                    lat: urlCenter.lat,\n                                    lng: urlCenter.lng,\n                                    zoom: urlCenter.zoom\n                                });\n                            }\n                        });\n                    }\n\n                    leafletScope.$watch(directiveName, function(center) {\n                        if (leafletScope.settingCenterFromLeaflet)\n                            return;\n                        //$log.debug(\"updated center model...\");\n                        // The center from the URL has priority\n                        if (isDefined(urlCenterHash)) {\n                            angular.copy(urlCenterHash, center);\n                            urlCenterHash = undefined;\n                        }\n\n                        if (!isValidCenter(center) && center.autoDiscover !== true) {\n                            $log.warn(errorHeader + \" invalid 'center'\");\n                            //map.setView([defaults.center.lat, defaults.center.lng], defaults.center.zoom);\n                            return;\n                        }\n\n                        if (center.autoDiscover === true) {\n                            if (!isNumber(center.zoom)) {\n                                map.setView([defaults.center.lat, defaults.center.lng], defaults.center.zoom);\n                            }\n                            if (isNumber(center.zoom) && center.zoom > defaults.center.zoom) {\n                                map.locate({\n                                    setView: true,\n                                    maxZoom: center.zoom\n                                });\n                            } else if (isDefined(defaults.maxZoom)) {\n                                map.locate({\n                                    setView: true,\n                                    maxZoom: defaults.maxZoom\n                                });\n                            } else {\n                                map.locate({\n                                    setView: true\n                                });\n                            }\n                            return;\n                        }\n\n                        if (mapReady && isSameCenterOnMap(center, map)) {\n                            //$log.debug(\"no need to update map again.\");\n                            return;\n                        }\n\n                        //$log.debug(\"updating map center...\", center);\n                        leafletScope.settingCenterFromScope = true;\n                        map.setView([center.lat, center.lng], center.zoom);\n                        leafletMapEvents.notifyCenterChangedToBounds(leafletScope, map);\n                        $timeout(function() {\n                            leafletScope.settingCenterFromScope = false;\n                            //$log.debug(\"allow center scope updates\");\n                        });\n                    }, true);\n\n                    map.whenReady(function() {\n                        mapReady = true;\n                    });\n\n                    map.on('moveend', function( /* event */ ) {\n                        // Resolve the center after the first map position\n                        _leafletCenter.resolve();\n                        leafletMapEvents.notifyCenterUrlHashChanged(leafletScope, map, attrs, $location.search());\n                        //$log.debug(\"updated center on map...\");\n                        if (isSameCenterOnMap(centerModel, map) || leafletScope.settingCenterFromScope) {\n                            //$log.debug(\"same center in model, no need to update again.\");\n                            return;\n                        }\n                        leafletScope.settingCenterFromLeaflet = true;\n                        safeApply(leafletScope, function(scope) {\n                            if (!leafletScope.settingCenterFromScope) {\n                                //$log.debug(\"updating center model...\", map.getCenter(), map.getZoom());\n                                angular.extend(scope[directiveName], {\n                                    lat: map.getCenter().lat,\n                                    lng: map.getCenter().lng,\n                                    zoom: map.getZoom(),\n                                    autoDiscover: false\n                                });\n                            }\n                            leafletMapEvents.notifyCenterChangedToBounds(leafletScope, map);\n                            $timeout(function() {\n                                leafletScope.settingCenterFromLeaflet = false;\n                            });\n                        });\n                    });\n\n                    if (centerModel.autoDiscover === true) {\n                        map.on('locationerror', function() {\n                            $log.warn(errorHeader + \" The Geolocation API is unauthorized on this page.\");\n                            if (isValidCenter(centerModel)) {\n                                map.setView([centerModel.lat, centerModel.lng], centerModel.zoom);\n                                leafletMapEvents.notifyCenterChangedToBounds(leafletScope, map);\n                            } else {\n                                map.setView([defaults.center.lat, defaults.center.lng], defaults.center.zoom);\n                                leafletMapEvents.notifyCenterChangedToBounds(leafletScope, map);\n                            }\n                        });\n                    }\n                });\n            }\n        };\n    }\n    ];\n});\n\ncenterDirectiveTypes.forEach(function(dirType){\n  angular.module(\"leaflet-directive\").directive(dirType, centerDirectives[dirType]);\n});\n\nangular.module(\"leaflet-directive\").directive('controls', [\"$log\", \"leafletHelpers\", \"leafletControlHelpers\", function ($log, leafletHelpers, leafletControlHelpers) {\n\n    return {\n        restrict: \"A\",\n        scope: false,\n        replace: false,\n        require: '?^leaflet',\n\n        link: function(scope, element, attrs, controller) {\n            if(!controller) {\n                return;\n            }\n\n            var createControl = leafletControlHelpers.createControl;\n            var isValidControlType = leafletControlHelpers.isValidControlType;\n            var leafletScope  = controller.getLeafletScope();\n            var isDefined = leafletHelpers.isDefined;\n            var isArray = leafletHelpers.isArray;\n            var leafletControls = {};\n            var errorHeader = leafletHelpers.errorHeader + ' [Controls] ';\n\n            controller.getMap().then(function(map) {\n\n                leafletScope.$watchCollection('controls', function(newControls) {\n\n                    // Delete controls from the array\n                    for (var name in leafletControls) {\n                        if (!isDefined(newControls[name])) {\n                            if (map.hasControl(leafletControls[name])) {\n                                map.removeControl(leafletControls[name]);\n                            }\n                            delete leafletControls[name];\n                        }\n                    }\n\n                    for (var newName in newControls) {\n                        var control;\n\n                        var controlType = isDefined(newControls[newName].type) ? newControls[newName].type : newName;\n\n                        if (!isValidControlType(controlType)) {\n                            $log.error(errorHeader + ' Invalid control type: ' + controlType + '.');\n                            return;\n                        }\n\n                        if (controlType !== 'custom') {\n                            control = createControl(controlType, newControls[newName]);\n                            map.addControl(control);\n                            leafletControls[newName] = control;\n                        } else {\n                            var customControlValue = newControls[newName];\n                            if (isArray(customControlValue)) {\n                                for (var i in customControlValue) {\n                                    var customControl = customControlValue[i];\n                                    map.addControl(customControl);\n                                    leafletControls[newName] = !isDefined(leafletControls[newName]) ? [customControl] : leafletControls[newName].concat([customControl]);\n                                }\n                            } else {\n                                map.addControl(customControlValue);\n                                leafletControls[newName] = customControlValue;\n                            }\n                        }\n                    }\n\n                });\n\n            });\n        }\n    };\n}]);\n\nangular.module(\"leaflet-directive\").directive(\"decorations\", [\"$log\", \"leafletHelpers\", function($log, leafletHelpers) {\n\n\treturn {\n\t\trestrict: \"A\",\n\t\tscope: false,\n\t\treplace: false,\n\t\trequire: 'leaflet',\n\n\t\tlink: function(scope, element, attrs, controller) {\n\t\t\tvar leafletScope = controller.getLeafletScope(),\n\t\t\t\tPolylineDecoratorPlugin = leafletHelpers.PolylineDecoratorPlugin,\n\t\t\t\tisDefined = leafletHelpers.isDefined,\n\t\t\t\tleafletDecorations = {};\n\n\t\t\t/* Creates an \"empty\" decoration with a set of coordinates, but no pattern. */\n\t\t\tfunction createDecoration(options) {\n\t\t\t\tif (isDefined(options) && isDefined(options.coordinates)) {\n\t\t\t\t\tif (!PolylineDecoratorPlugin.isLoaded()) {\n\t\t\t\t\t\t$log.error('[AngularJS - Leaflet] The PolylineDecorator Plugin is not loaded.');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn L.polylineDecorator(options.coordinates);\n\t\t\t}\n\n\t\t\t/* Updates the path and the patterns for the provided decoration, and returns the decoration. */\n\t\t\tfunction setDecorationOptions(decoration, options) {\n\t\t\t\tif (isDefined(decoration) && isDefined(options)) {\n\t\t\t\t\tif (isDefined(options.coordinates) && isDefined(options.patterns)) {\n\t\t\t\t\t\tdecoration.setPaths(options.coordinates);\n\t\t\t\t\t\tdecoration.setPatterns(options.patterns);\n\t\t\t\t\t\treturn decoration;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontroller.getMap().then(function(map) {\n\t\t\t\tleafletScope.$watch(\"decorations\", function(newDecorations) {\n\t\t\t\t\tfor (var name in leafletDecorations) {\n\t\t\t\t\t\tif (!isDefined(newDecorations[name]) || !angular.equals(newDecorations[name], leafletDecorations)) {\n\t\t\t\t\t\t\tmap.removeLayer(leafletDecorations[name]);\n\t\t\t\t\t\t\tdelete leafletDecorations[name];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (var newName in newDecorations) {\n\t\t\t\t\t\tvar decorationData = newDecorations[newName],\n\t\t\t\t\t\t\tnewDecoration = createDecoration(decorationData);\n\n\t\t\t\t\t\tif (isDefined(newDecoration)) {\n\t\t\t\t\t\t\tleafletDecorations[newName] = newDecoration;\n\t\t\t\t\t\t\tmap.addLayer(newDecoration);\n\t\t\t\t\t\t\tsetDecorationOptions(newDecoration, decorationData);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, true);\n\t\t\t});\n\t\t}\n\t};\n}]);\n\nangular.module(\"leaflet-directive\").directive('eventBroadcast', [\"$log\", \"$rootScope\", \"leafletHelpers\", \"leafletMapEvents\", \"leafletIterators\", function ($log, $rootScope, leafletHelpers, leafletMapEvents, leafletIterators) {\n\n    return {\n        restrict: \"A\",\n        scope: false,\n        replace: false,\n        require: 'leaflet',\n\n        link: function(scope, element, attrs, controller) {\n            var isObject = leafletHelpers.isObject,\n                isDefined = leafletHelpers.isDefined,\n                leafletScope  = controller.getLeafletScope(),\n                eventBroadcast = leafletScope.eventBroadcast,\n                availableMapEvents = leafletMapEvents.getAvailableMapEvents(),\n                addEvents = leafletMapEvents.addEvents;\n\n            controller.getMap().then(function(map) {\n\n                var mapEvents = [],\n                    logic = \"broadcast\";\n\n                // We have a possible valid object\n                if (!isDefined(eventBroadcast.map)) {\n                    // We do not have events enable/disable do we do nothing (all enabled by default)\n                    mapEvents = availableMapEvents;\n                } else if (!isObject(eventBroadcast.map)) {\n                    // Not a valid object\n                    $log.warn(\"[AngularJS - Leaflet] event-broadcast.map must be an object check your model.\");\n                } else {\n                    // We have a possible valid map object\n                    // Event propadation logic\n                    if (eventBroadcast.map.logic !== \"emit\" && eventBroadcast.map.logic !== \"broadcast\") {\n                        // This is an error\n                        $log.warn(\"[AngularJS - Leaflet] Available event propagation logic are: 'emit' or 'broadcast'.\");\n                    } else {\n                        logic = eventBroadcast.map.logic;\n                    }\n\n                    if (!(isObject(eventBroadcast.map.enable) && eventBroadcast.map.enable.length >= 0)) {\n                        $log.warn(\"[AngularJS - Leaflet] event-broadcast.map.enable must be an object check your model.\");\n                    } else {\n                        // Enable events\n                        leafletIterators.each(eventBroadcast.map.enable, function(eventName) {\n                            // Do we have already the event enabled?\n                            if (mapEvents.indexOf(eventName) === -1 && availableMapEvents.indexOf(eventName) !== -1) {\n                                mapEvents.push(eventName);\n                            }\n                        });\n                    }\n\n                }\n                // as long as the map is removed in the root leaflet directive we\n                // do not need ot clean up the events as leaflet does it itself\n                addEvents(map, mapEvents, \"eventName\", leafletScope, logic);\n            });\n        }\n    };\n}]);\n\nangular.module(\"leaflet-directive\")\n.directive('geojson', [\"$log\", \"$rootScope\", \"leafletData\", \"leafletHelpers\", \"leafletWatchHelpers\", \"leafletDirectiveControlsHelpers\", \"leafletIterators\", \"leafletGeoJsonEvents\", function ($log, $rootScope, leafletData, leafletHelpers,\n    leafletWatchHelpers, leafletDirectiveControlsHelpers,leafletIterators, leafletGeoJsonEvents) {\n    var _maybeWatch = leafletWatchHelpers.maybeWatch,\n        _watchOptions = leafletHelpers.watchOptions,\n        _extendDirectiveControls = leafletDirectiveControlsHelpers.extend,\n        hlp = leafletHelpers,\n        $it = leafletIterators;\n\n    return {\n        restrict: \"A\",\n        scope: false,\n        replace: false,\n        require: 'leaflet',\n\n        link: function(scope, element, attrs, controller) {\n            var isDefined = leafletHelpers.isDefined,\n                leafletScope  = controller.getLeafletScope(),\n                leafletGeoJSON = {},\n                _hasSetLeafletData = false;\n\n            controller.getMap().then(function(map) {\n                var watchOptions = leafletScope.geojsonWatchOptions || _watchOptions;\n\n                var _hookUpEvents = function(geojson, maybeName){\n                    var onEachFeature;\n\n                    if (angular.isFunction(geojson.onEachFeature)) {\n                        onEachFeature = geojson.onEachFeature;\n                    } else {\n                        onEachFeature = function(feature, layer) {\n                            if (leafletHelpers.LabelPlugin.isLoaded() && isDefined(feature.properties.description)) {\n                                layer.bindLabel(feature.properties.description);\n                            }\n\n                            leafletGeoJsonEvents.bindEvents(attrs.id, layer, null, feature,\n                                leafletScope, maybeName,\n                                {resetStyleOnMouseout: geojson.resetStyleOnMouseout,\n                                mapId: attrs.id});\n                        };\n                    }\n                    return onEachFeature;\n                };\n\n                var isNested = (hlp.isDefined(attrs.geojsonNested) &&\n                    hlp.isTruthy(attrs.geojsonNested));\n\n                var _clean = function(){\n                    if(!leafletGeoJSON)\n                        return;\n                    var _remove = function(lObject) {\n                        if (isDefined(lObject) && map.hasLayer(lObject)) {\n                            map.removeLayer(lObject);\n                        }\n                    };\n                    if(isNested) {\n                        $it.each(leafletGeoJSON, function(lObject) {\n                            _remove(lObject);\n                        });\n                        return;\n                    }\n                    _remove(leafletGeoJSON);\n                };\n\n                var _addGeojson = function(model, maybeName){\n                    var geojson = angular.copy(model);\n                    if (!(isDefined(geojson) && isDefined(geojson.data))) {\n                        return;\n                    }\n                    var onEachFeature = _hookUpEvents(geojson, maybeName);\n\n                    if (!isDefined(geojson.options)) {\n                        //right here is why we use a clone / copy (we modify and thus)\n                        //would kick of a watcher.. we need to be more careful everywhere\n                        //for stuff like this\n                        geojson.options = {\n                            style: geojson.style,\n                            filter: geojson.filter,\n                            onEachFeature: onEachFeature,\n                            pointToLayer: geojson.pointToLayer\n                        };\n                    }\n\n                    var lObject = L.geoJson(geojson.data, geojson.options);\n\n                    if(maybeName && hlp.isString(maybeName)){\n                        leafletGeoJSON[maybeName] = lObject;\n                    }\n                    else{\n                        leafletGeoJSON = lObject;\n                    }\n\n                    lObject.addTo(map);\n\n                    if(!_hasSetLeafletData){//only do this once and play with the same ref forever\n                        _hasSetLeafletData = true;\n                        leafletData.setGeoJSON(leafletGeoJSON, attrs.id);\n                    }\n                };\n\n                var _create = function(model){\n                    _clean();\n                    if(isNested) {\n                        if(!model || !Object.keys(model).length)\n                            return;\n                        $it.each(model, function(m, name) {\n                            //name could be layerName and or groupName\n                            //for now it is not tied to a layer\n                            _addGeojson(m,name);\n                        });\n                        return;\n                    }\n                    _addGeojson(model);\n                };\n\n                _extendDirectiveControls(attrs.id, 'geojson', _create, _clean);\n\n                _maybeWatch(leafletScope,'geojson', watchOptions, function(geojson){\n                    _create(geojson);\n                });\n            });\n        }\n    };\n}]);\n\nangular.module(\"leaflet-directive\").directive('layercontrol', [\"$filter\", \"$log\", \"leafletData\", \"leafletHelpers\", function ($filter, $log, leafletData, leafletHelpers) {\n\n    return {\n        restrict: \"E\",\n        scope: {\n            icons: '=?',\n            autoHideOpacity: '=?', // Hide other opacity controls when one is activated.\n            showGroups: '=?', // Hide other opacity controls when one is activated.\n            title: '@',\n            baseTitle: '@',\n            overlaysTitle: '@'\n        },\n        replace: true,\n        transclude: false,\n        require: '^leaflet',\n        controller: [\"$scope\", \"$element\", \"$sce\", function ($scope, $element, $sce) {\n            $log.debug('[Angular Directive - Layers] layers', $scope, $element);\n            var safeApply = leafletHelpers.safeApply,\n            isDefined = leafletHelpers.isDefined;\n            angular.extend($scope, {\n                baselayer: '',\n                oldGroup: '',\n                layerProperties: {},\n                groupProperties: {},\n                rangeIsSupported: leafletHelpers.rangeIsSupported(),\n                changeBaseLayer: function(key, e) {\n                    leafletHelpers.safeApply($scope, function(scp) {\n                        scp.baselayer = key;\n                        leafletData.getMap().then(function(map) {\n                            leafletData.getLayers().then(function(leafletLayers) {\n                                if(map.hasLayer(leafletLayers.baselayers[key])) {\n                                    return;\n                                }\n                                for(var i in scp.layers.baselayers) {\n                                    scp.layers.baselayers[i].icon = scp.icons.unradio;\n                                    if(map.hasLayer(leafletLayers.baselayers[i])) {\n                                        map.removeLayer(leafletLayers.baselayers[i]);\n                                    }\n                                }\n                                map.addLayer(leafletLayers.baselayers[key]);\n                                scp.layers.baselayers[key].icon = $scope.icons.radio;\n                            });\n                        });\n                    });\n                    e.preventDefault();\n                },\n                moveLayer: function(ly, newIndex, e) {\n                    var delta = Object.keys($scope.layers.baselayers).length;\n                    if(newIndex >= (1+delta) && newIndex <= ($scope.overlaysArray.length+delta)) {\n                        var oldLy;\n                        for(var key in $scope.layers.overlays) {\n                            if($scope.layers.overlays[key].index === newIndex) {\n                                oldLy = $scope.layers.overlays[key];\n                                break;\n                            }\n                        }\n                        if(oldLy) {\n                            safeApply($scope, function() {\n                                oldLy.index = ly.index;\n                                ly.index = newIndex;\n                            });\n                        }\n                    }\n                    e.stopPropagation();\n                    e.preventDefault();\n                },\n                initIndex: function(layer, idx) {\n                    var delta = Object.keys($scope.layers.baselayers).length;\n                    layer.index = isDefined(layer.index)? layer.index:idx+delta+1;\n                },\n                initGroup: function(groupName) {\n                    $scope.groupProperties[groupName] = $scope.groupProperties[groupName]? $scope.groupProperties[groupName]:{};\n                },\n                toggleOpacity: function(e, layer) {\n                    if(layer.visible) {\n                        if($scope.autoHideOpacity && !$scope.layerProperties[layer.name].opacityControl) {\n                            for(var k in $scope.layerProperties) {\n                                $scope.layerProperties[k].opacityControl = false;\n                            }\n                        }\n                        $scope.layerProperties[layer.name].opacityControl = !$scope.layerProperties[layer.name].opacityControl;\n                    }\n                    e.stopPropagation();\n                    e.preventDefault();\n                },\n                toggleLegend: function(layer) {\n                    $scope.layerProperties[layer.name].showLegend = !$scope.layerProperties[layer.name].showLegend;\n                },\n                showLegend: function(layer) {\n                    return layer.legend && $scope.layerProperties[layer.name].showLegend;\n                },\n                unsafeHTML: function(html) {\n                    return $sce.trustAsHtml(html);\n                },\n                getOpacityIcon: function(layer) {\n                    return layer.visible && $scope.layerProperties[layer.name].opacityControl? $scope.icons.close:$scope.icons.open;\n                },\n                getGroupIcon: function(group) {\n                    return group.visible? $scope.icons.check:$scope.icons.uncheck;\n                },\n                changeOpacity: function(layer) {\n                    var op = $scope.layerProperties[layer.name].opacity;\n                    leafletData.getMap().then(function(map) {\n                        leafletData.getLayers().then(function(leafletLayers) {\n                            var ly;\n                            for(var k in $scope.layers.overlays) {\n                                if($scope.layers.overlays[k] === layer) {\n                                    ly = leafletLayers.overlays[k];\n                                    break;\n                                }\n                            }\n\n                            if(map.hasLayer(ly)) {\n                                if(ly.setOpacity) {\n                                    ly.setOpacity(op/100);\n                                }\n                                if(ly.getLayers && ly.eachLayer) {\n                                    ly.eachLayer(function(lay) {\n                                        if(lay.setOpacity) {\n                                            lay.setOpacity(op/100);\n                                        }\n                                    });\n                                }\n                            }\n                        });\n                    });\n                },\n                changeGroupVisibility: function(groupName) {\n                    if(!isDefined($scope.groupProperties[groupName])) {\n                        return;\n                    }\n                    var visible = $scope.groupProperties[groupName].visible;\n                    for(var k in $scope.layers.overlays) {\n                        var layer = $scope.layers.overlays[k];\n                        if(layer.group === groupName) {\n                            layer.visible = visible;\n                        }\n                    }\n                }\n            });\n\n            var div = $element.get(0);\n            if (!L.Browser.touch) {\n                L.DomEvent.disableClickPropagation(div);\n                L.DomEvent.on(div, 'mousewheel', L.DomEvent.stopPropagation);\n            } else {\n                L.DomEvent.on(div, 'click', L.DomEvent.stopPropagation);\n            }\n        }],\n        template:\n        '<div class=\"angular-leaflet-control-layers\" ng-show=\"overlaysArray.length\">' +\n            '<h4 ng-if=\"title\">{{ title }}</h4>' +\n            '<div class=\"lf-baselayers\">' +\n                '<h5 class=\"lf-title\" ng-if=\"baseTitle\">{{ baseTitle }}</h5>' +\n                '<div class=\"lf-row\" ng-repeat=\"(key, layer) in baselayersArray\">' +\n                    '<label class=\"lf-icon-bl\" ng-click=\"changeBaseLayer(key, $event)\">' +\n                        '<input class=\"leaflet-control-layers-selector\" type=\"radio\" name=\"lf-radio\" ' +\n                            'ng-show=\"false\" ng-checked=\"baselayer === key\" ng-value=\"key\" /> ' +\n                        '<i class=\"lf-icon lf-icon-radio\" ng-class=\"layer.icon\"></i>' +\n                        '<div class=\"lf-text\">{{layer.name}}</div>' +\n                    '</label>' +\n                '</div>' +\n            '</div>' +\n            '<div class=\"lf-overlays\">' +\n                '<h5 class=\"lf-title\" ng-if=\"overlaysTitle\">{{ overlaysTitle }}</h5>' +\n                '<div class=\"lf-container\">' +\n                    '<div class=\"lf-row\" ng-repeat=\"layer in (o = (overlaysArray | orderBy:\\'index\\':order))\" ng-init=\"initIndex(layer, $index)\">' +\n                        '<label class=\"lf-icon-ol-group\" ng-if=\"showGroups &amp;&amp; layer.group &amp;&amp; layer.group != o[$index-1].group\">' +\n                            '<input class=\"lf-control-layers-selector\" type=\"checkbox\" ng-show=\"false\" ' +\n                                'ng-change=\"changeGroupVisibility(layer.group)\" ng-model=\"groupProperties[layer.group].visible\"/> ' +\n                            '<i class=\"lf-icon lf-icon-check\" ng-class=\"getGroupIcon(groupProperties[layer.group])\"></i>' +\n                            '<div class=\"lf-text\">{{ layer.group }}</div>' +\n                        '</label>'+\n                        '<label class=\"lf-icon-ol\">' +\n                            '<input class=\"lf-control-layers-selector\" type=\"checkbox\" ng-show=\"false\" ng-model=\"layer.visible\"/> ' +\n                            '<i class=\"lf-icon lf-icon-check\" ng-class=\"layer.icon\"></i>' +\n                            '<div class=\"lf-text\">{{layer.name}}</div>' +\n                        '</label>'+\n                        '<div class=\"lf-icons\">' +\n                            '<i class=\"lf-icon lf-up\" ng-class=\"icons.up\" ng-click=\"moveLayer(layer, layer.index - orderNumber, $event)\"></i> ' +\n                            '<i class=\"lf-icon lf-down\" ng-class=\"icons.down\" ng-click=\"moveLayer(layer, layer.index + orderNumber, $event)\"></i> ' +\n                            '<i class=\"lf-icon lf-toggle-legend\" ng-class=\"icons.toggleLegend\" ng-if=\"layer.legend\" ng-click=\"toggleLegend(layer)\"></i> ' +\n                            '<i class=\"lf-icon lf-open\" ng-class=\"getOpacityIcon(layer)\" ng-click=\"toggleOpacity($event, layer)\"></i>' +\n                        '</div>' +\n                        '<div class=\"lf-legend\" ng-if=\"showLegend(layer)\" ng-bind-html=\"unsafeHTML(layer.legend)\"></div>' +\n                        '<div class=\"lf-opacity clearfix\" ng-if=\"layer.visible &amp;&amp; layerProperties[layer.name].opacityControl\">' +\n                            '<label ng-if=\"rangeIsSupported\" class=\"pull-left\" style=\"width: 50%\">0</label>' +\n                            '<label ng-if=\"rangeIsSupported\" class=\"pull-left text-right\" style=\"width: 50%\">100</label>' +\n                            '<input ng-if=\"rangeIsSupported\" class=\"clearfix\" type=\"range\" min=\"0\" max=\"100\" class=\"lf-opacity-control\" ' +\n                                'ng-model=\"layerProperties[layer.name].opacity\" ng-change=\"changeOpacity(layer)\"/>' +\n                            '<h6 ng-if=\"!rangeIsSupported\">Range is not supported in this browser</h6>' +\n                        '</div>' +\n                    '</div>' +\n                '</div>' +\n            '</div>' +\n        '</div>',\n        link: function(scope, element, attrs, controller) {\n            var isDefined = leafletHelpers.isDefined,\n            leafletScope = controller.getLeafletScope(),\n            layers = leafletScope.layers;\n\n            scope.$watch('icons', function() {\n                var defaultIcons = {\n                    uncheck: 'fa fa-square-o',\n                    check: 'fa fa-check-square-o',\n                    radio: 'fa fa-dot-circle-o',\n                    unradio: 'fa fa-circle-o',\n                    up: 'fa fa-angle-up',\n                    down: 'fa fa-angle-down',\n                    open: 'fa fa-angle-double-down',\n                    close: 'fa fa-angle-double-up',\n                    toggleLegend: 'fa fa-pencil-square-o'\n                };\n                if(isDefined(scope.icons)) {\n                    angular.extend(defaultIcons, scope.icons);\n                    angular.extend(scope.icons, defaultIcons);\n                } else {\n                    scope.icons = defaultIcons;\n                }\n            });\n\n            // Setting layer stack order.\n            attrs.order = (isDefined(attrs.order) && (attrs.order === 'normal' || attrs.order === 'reverse'))? attrs.order:'normal';\n            scope.order = attrs.order === 'normal';\n            scope.orderNumber = attrs.order === 'normal'? -1:1;\n\n            scope.layers = layers;\n            controller.getMap().then(function(map) {\n                leafletScope.$watch('layers.baselayers', function(newBaseLayers) {\n                    var baselayersArray = {};\n                    leafletData.getLayers().then(function(leafletLayers) {\n                        var key;\n                        for(key in newBaseLayers) {\n                            var layer = newBaseLayers[key];\n                            layer.icon = scope.icons[map.hasLayer(leafletLayers.baselayers[key])? 'radio':'unradio'];\n                            baselayersArray[key] = layer;\n                        }\n                        scope.baselayersArray = baselayersArray;\n                    });\n                });\n\n                leafletScope.$watch('layers.overlays', function(newOverlayLayers) {\n                    var overlaysArray = [];\n                    var groupVisibleCount = {};\n                    leafletData.getLayers().then(function(leafletLayers) {\n                        var key;\n                        for(key in newOverlayLayers) {\n                            var layer = newOverlayLayers[key];\n                            layer.icon = scope.icons[(layer.visible? 'check':'uncheck')];\n                            overlaysArray.push(layer);\n                            if(!isDefined(scope.layerProperties[layer.name])) {\n                                scope.layerProperties[layer.name] = {\n                                    opacity: isDefined(layer.layerOptions.opacity)? layer.layerOptions.opacity*100:100,\n                                    opacityControl: false,\n                                    showLegend: true\n                                };\n                            }\n                            if(isDefined(layer.group)) {\n                                if(!isDefined(scope.groupProperties[layer.group])) {\n                                    scope.groupProperties[layer.group] = {\n                                        visible: false\n                                    };\n                                }\n                                groupVisibleCount[layer.group] = isDefined(groupVisibleCount[layer.group])? groupVisibleCount[layer.group]:{\n                                    count: 0,\n                                    visibles: 0\n                                };\n                                groupVisibleCount[layer.group].count++;\n                                if(layer.visible) {\n                                    groupVisibleCount[layer.group].visibles++;\n                                }\n                            }\n                            if(isDefined(layer.index) && leafletLayers.overlays[key].setZIndex) {\n                                leafletLayers.overlays[key].setZIndex(newOverlayLayers[key].index);\n                            }\n                        }\n\n                        for(key in groupVisibleCount) {\n                            scope.groupProperties[key].visible = groupVisibleCount[key].visibles === groupVisibleCount[key].count;\n                        }\n                        scope.overlaysArray = overlaysArray;\n                    });\n                }, true);\n            });\n        }\n    };\n}]);\n\nangular.module(\"leaflet-directive\").directive('layers', [\"$log\", \"$q\", \"leafletData\", \"leafletHelpers\", \"leafletLayerHelpers\", \"leafletControlHelpers\", function ($log, $q, leafletData, leafletHelpers, leafletLayerHelpers, leafletControlHelpers) {\n\n    return {\n        restrict: \"A\",\n        scope: false,\n        replace: false,\n        require: 'leaflet',\n        controller: [\"$scope\", function ($scope) {\n            $scope._leafletLayers = $q.defer();\n            this.getLayers = function () {\n                return $scope._leafletLayers.promise;\n            };\n        }],\n        link: function(scope, element, attrs, controller){\n            var isDefined = leafletHelpers.isDefined,\n                leafletLayers = {},\n                leafletScope  = controller.getLeafletScope(),\n                layers = leafletScope.layers,\n                createLayer = leafletLayerHelpers.createLayer,\n                safeAddLayer = leafletLayerHelpers.safeAddLayer,\n                safeRemoveLayer = leafletLayerHelpers.safeRemoveLayer,\n                updateLayersControl = leafletControlHelpers.updateLayersControl,\n                isLayersControlVisible = false;\n\n            controller.getMap().then(function(map) {\n\n                // We have baselayers to add to the map\n                scope._leafletLayers.resolve(leafletLayers);\n                leafletData.setLayers(leafletLayers, attrs.id);\n\n                leafletLayers.baselayers = {};\n                leafletLayers.overlays = {};\n\n                var mapId = attrs.id;\n\n                // Setup all baselayers definitions\n                var oneVisibleLayer = false;\n                for (var layerName in layers.baselayers) {\n                    var newBaseLayer = createLayer(layers.baselayers[layerName]);\n                    if (!isDefined(newBaseLayer)) {\n                        delete layers.baselayers[layerName];\n                        continue;\n                    }\n                    leafletLayers.baselayers[layerName] = newBaseLayer;\n                    // Only add the visible layer to the map, layer control manages the addition to the map\n                    // of layers in its control\n                    if (layers.baselayers[layerName].top === true) {\n                        safeAddLayer(map, leafletLayers.baselayers[layerName]);\n                        oneVisibleLayer = true;\n                    }\n                }\n\n                // If there is no visible layer add first to the map\n                if (!oneVisibleLayer && Object.keys(leafletLayers.baselayers).length > 0) {\n                    safeAddLayer(map, leafletLayers.baselayers[Object.keys(layers.baselayers)[0]]);\n                }\n\n                // Setup the Overlays\n                for (layerName in layers.overlays) {\n                    if(layers.overlays[layerName].type === 'cartodb') {\n\n                    }\n                    var newOverlayLayer = createLayer(layers.overlays[layerName]);\n                    if (!isDefined(newOverlayLayer)) {\n                        delete layers.overlays[layerName];\n                        continue;\n                    }\n                    leafletLayers.overlays[layerName] = newOverlayLayer;\n                    // Only add the visible overlays to the map\n                    if (layers.overlays[layerName].visible === true) {\n                        safeAddLayer(map, leafletLayers.overlays[layerName]);\n                    }\n                }\n\n                // Watch for the base layers\n                leafletScope.$watch('layers.baselayers', function(newBaseLayers, oldBaseLayers) {\n                    if(angular.equals(newBaseLayers, oldBaseLayers)) {\n                        isLayersControlVisible = updateLayersControl(map, mapId, isLayersControlVisible, newBaseLayers, layers.overlays, leafletLayers);\n                        return true;\n                    }\n                    // Delete layers from the array\n                    for (var name in leafletLayers.baselayers) {\n                        if (!isDefined(newBaseLayers[name]) || newBaseLayers[name].doRefresh) {\n                            // Remove from the map if it's on it\n                            if (map.hasLayer(leafletLayers.baselayers[name])) {\n                                map.removeLayer(leafletLayers.baselayers[name]);\n                            }\n                            delete leafletLayers.baselayers[name];\n\n                            if (newBaseLayers[name] && newBaseLayers[name].doRefresh) {\n                                newBaseLayers[name].doRefresh = false;\n                            }\n                        }\n                    }\n                    // add new layers\n                    for (var newName in newBaseLayers) {\n                        if (!isDefined(leafletLayers.baselayers[newName])) {\n                            var testBaseLayer = createLayer(newBaseLayers[newName]);\n                            if (isDefined(testBaseLayer)) {\n                                leafletLayers.baselayers[newName] = testBaseLayer;\n                                // Only add the visible layer to the map\n                                if (newBaseLayers[newName].top === true) {\n                                    safeAddLayer(map, leafletLayers.baselayers[newName]);\n                                }\n                            }\n                        } else {\n                            if (newBaseLayers[newName].top === true && !map.hasLayer(leafletLayers.baselayers[newName])) {\n                                safeAddLayer(map, leafletLayers.baselayers[newName]);\n                            } else if (newBaseLayers[newName].top === false && map.hasLayer(leafletLayers.baselayers[newName])) {\n                                map.removeLayer(leafletLayers.baselayers[newName]);\n                            }\n                        }\n                    }\n\n                    //we have layers, so we need to make, at least, one active\n                    var found = false;\n                    // search for an active layer\n                    for (var key in leafletLayers.baselayers) {\n                        if (map.hasLayer(leafletLayers.baselayers[key])) {\n                            found = true;\n                            break;\n                        }\n                    }\n                    // If there is no active layer make one active\n                    if (!found && Object.keys(leafletLayers.baselayers).length > 0) {\n                        safeAddLayer(map, leafletLayers.baselayers[Object.keys(leafletLayers.baselayers)[0]]);\n                    }\n\n                    // Only show the layers switch selector control if we have more than one baselayer + overlay\n                    isLayersControlVisible = updateLayersControl(map, mapId, isLayersControlVisible, newBaseLayers, layers.overlays, leafletLayers);\n                }, true);\n\n                // Watch for the overlay layers\n                leafletScope.$watch('layers.overlays', function(newOverlayLayers, oldOverlayLayers) {\n                    if(angular.equals(newOverlayLayers, oldOverlayLayers)) {\n                        isLayersControlVisible = updateLayersControl(map, mapId, isLayersControlVisible, layers.baselayers, newOverlayLayers, leafletLayers);\n                        return true;\n                    }\n\n                    // Delete layers from the array\n                    for (var name in leafletLayers.overlays) {\n                        if (!isDefined(newOverlayLayers[name]) || newOverlayLayers[name].doRefresh) {\n                            // Remove from the map if it's on it\n                            if (map.hasLayer(leafletLayers.overlays[name])) {\n                                // Safe remove when ArcGIS layers is loading.\n                                var options = isDefined(newOverlayLayers[name])?\n                                    newOverlayLayers[name].layerOptions:null;\n                                safeRemoveLayer(map, leafletLayers.overlays[name], options);\n                            }\n                            // TODO: Depending on the layer type we will have to delete what's included on it\n                            delete leafletLayers.overlays[name];\n\n                            if (newOverlayLayers[name] && newOverlayLayers[name].doRefresh) {\n                                newOverlayLayers[name].doRefresh = false;\n                            }\n                        }\n                    }\n\n                    // add new overlays\n                    for (var newName in newOverlayLayers) {\n                        if (!isDefined(leafletLayers.overlays[newName])) {\n                            var testOverlayLayer = createLayer(newOverlayLayers[newName]);\n                            if (!isDefined(testOverlayLayer)) {\n                                // If the layer creation fails, continue to the next overlay\n                                continue;\n                            }\n                            leafletLayers.overlays[newName] = testOverlayLayer;\n                            if (newOverlayLayers[newName].visible === true) {\n                                safeAddLayer(map, leafletLayers.overlays[newName]);\n                            }\n                        } else {\n                            // check for the .visible property to hide/show overLayers\n                            if (newOverlayLayers[newName].visible && !map.hasLayer(leafletLayers.overlays[newName])) {\n                                safeAddLayer(map, leafletLayers.overlays[newName]);\n                            } else if (newOverlayLayers[newName].visible === false && map.hasLayer(leafletLayers.overlays[newName])) {\n                                // Safe remove when ArcGIS layers is loading.\n                                safeRemoveLayer(map, leafletLayers.overlays[newName], newOverlayLayers[newName].layerOptions);\n                            }\n                        }\n\n                        //refresh heatmap data if present\n                        if (newOverlayLayers[newName].visible && map._loaded && newOverlayLayers[newName].data && newOverlayLayers[newName].type === \"heatmap\") {\n                            leafletLayers.overlays[newName].setData(newOverlayLayers[newName].data);\n                            leafletLayers.overlays[newName].update();\n                        }\n                    }\n\n                    // Only add the layers switch selector control if we have more than one baselayer + overlay\n                    isLayersControlVisible = updateLayersControl(map, mapId, isLayersControlVisible, layers.baselayers, newOverlayLayers, leafletLayers);\n                }, true);\n            });\n        }\n    };\n}]);\n\nangular.module(\"leaflet-directive\").directive('legend', [\"$log\", \"$http\", \"leafletHelpers\", \"leafletLegendHelpers\", function ($log, $http, leafletHelpers, leafletLegendHelpers) {\n\n        return {\n            restrict: \"A\",\n            scope: false,\n            replace: false,\n            require: 'leaflet',\n\n            link: function (scope, element, attrs, controller) {\n\n                var isArray = leafletHelpers.isArray,\n                    isDefined = leafletHelpers.isDefined,\n                    isFunction = leafletHelpers.isFunction,\n                    leafletScope = controller.getLeafletScope(),\n                    legend = leafletScope.legend;\n\n                var legendClass;\n                var position;\n                var leafletLegend;\n                var type;\n\n                leafletScope.$watch('legend', function (newLegend) {\n\n                    if (isDefined(newLegend)) {\n\n                        legendClass = newLegend.legendClass ? newLegend.legendClass : \"legend\";\n\n                        position = newLegend.position || 'bottomright';\n\n                        // default to arcgis\n                        type = newLegend.type || 'arcgis';\n                    }\n\n                }, true);\n\n                controller.getMap().then(function (map) {\n\n                    leafletScope.$watch('legend', function (newLegend) {\n\n                        if (!isDefined(newLegend)) {\n\n                            if (isDefined(leafletLegend)) {\n                                leafletLegend.removeFrom(map);\n                                leafletLegend= null;\n                            }\n\n                            return;\n                        }\n\n                        if (!isDefined(newLegend.url) && (type === 'arcgis') && (!isArray(newLegend.colors) || !isArray(newLegend.labels) || newLegend.colors.length !== newLegend.labels.length)) {\n\n                            $log.warn(\"[AngularJS - Leaflet] legend.colors and legend.labels must be set.\");\n\n                            return;\n                        }\n\n                        if (isDefined(newLegend.url)) {\n\n                            $log.info(\"[AngularJS - Leaflet] loading legend service.\");\n\n                            return;\n                        }\n\n                        if (isDefined(leafletLegend)) {\n                            leafletLegend.removeFrom(map);\n                            leafletLegend= null;\n                        }\n\n                        leafletLegend = L.control({\n                            position: position\n                        });\n                        if (type === 'arcgis') {\n                            leafletLegend.onAdd = leafletLegendHelpers.getOnAddArrayLegend(newLegend, legendClass);\n                        }\n                        leafletLegend.addTo(map);\n\n                    });\n\n                    leafletScope.$watch('legend.url', function (newURL) {\n\n                        if (!isDefined(newURL)) {\n                            return;\n                        }\n                        $http.get(newURL)\n                            .success(function (legendData) {\n\n                                if (isDefined(leafletLegend)) {\n\n                                    leafletLegendHelpers.updateLegend(leafletLegend.getContainer(), legendData, type, newURL);\n\n                                } else {\n\n                                    leafletLegend = L.control({\n                                        position: position\n                                    });\n                                    leafletLegend.onAdd = leafletLegendHelpers.getOnAddLegend(legendData, legendClass, type, newURL);\n                                    leafletLegend.addTo(map);\n                                }\n\n                                if (isDefined(legend.loadedData) && isFunction(legend.loadedData)) {\n                                    legend.loadedData();\n                                }\n                            })\n                            .error(function () {\n                                $log.warn('[AngularJS - Leaflet] legend.url not loaded.');\n                            });\n                    });\n\n                });\n            }\n        };\n    }]);\n\nangular.module(\"leaflet-directive\").directive('markers',\n    [\"$log\", \"$rootScope\", \"$q\", \"leafletData\", \"leafletHelpers\", \"leafletMapDefaults\", \"leafletMarkersHelpers\", \"leafletMarkerEvents\", \"leafletIterators\", \"leafletWatchHelpers\", \"leafletDirectiveControlsHelpers\", function ($log, $rootScope, $q, leafletData, leafletHelpers, leafletMapDefaults,\n              leafletMarkersHelpers, leafletMarkerEvents, leafletIterators, leafletWatchHelpers,\n              leafletDirectiveControlsHelpers) {\n    //less terse vars to helpers\n    var isDefined = leafletHelpers.isDefined,\n        errorHeader = leafletHelpers.errorHeader,\n        Helpers = leafletHelpers,\n        isString = leafletHelpers.isString,\n        addMarkerWatcher = leafletMarkersHelpers.addMarkerWatcher,\n        updateMarker = leafletMarkersHelpers.updateMarker,\n        listenMarkerEvents = leafletMarkersHelpers.listenMarkerEvents,\n        addMarkerToGroup = leafletMarkersHelpers.addMarkerToGroup,\n        createMarker = leafletMarkersHelpers.createMarker,\n        deleteMarker = leafletMarkersHelpers.deleteMarker,\n        $it = leafletIterators,\n        _markersWatchOptions = leafletHelpers.watchOptions,\n        maybeWatch = leafletWatchHelpers.maybeWatch,\n        extendDirectiveControls = leafletDirectiveControlsHelpers.extend;\n\n    var _getLMarker = function(leafletMarkers, name, maybeLayerName){\n        if(!Object.keys(leafletMarkers).length) return;\n        if(maybeLayerName && isString(maybeLayerName)){\n            if(!leafletMarkers[maybeLayerName] || !Object.keys(leafletMarkers[maybeLayerName]).length)\n                return;\n            return leafletMarkers[maybeLayerName][name];\n        }\n        return leafletMarkers[name];\n    };\n\n    var _setLMarker = function(lObject, leafletMarkers, name, maybeLayerName){\n        if(maybeLayerName && isString(maybeLayerName)){\n            if(!isDefined(leafletMarkers[maybeLayerName]))\n                leafletMarkers[maybeLayerName] = {};\n            leafletMarkers[maybeLayerName][name] = lObject;\n        }\n        else\n            leafletMarkers[name] = lObject;\n        return lObject;\n    };\n\n    var _maybeAddMarkerToLayer = function(layerName, layers, model, marker, doIndividualWatch, map){\n\n        if (!isString(layerName)) {\n            $log.error(errorHeader + ' A layername must be a string');\n            return false;\n        }\n\n        if (!isDefined(layers)) {\n            $log.error(errorHeader + ' You must add layers to the directive if the markers are going to use this functionality.');\n            return false;\n        }\n\n        if (!isDefined(layers.overlays) || !isDefined(layers.overlays[layerName])) {\n            $log.error(errorHeader +' A marker can only be added to a layer of type \"group\"');\n            return false;\n        }\n        var layerGroup = layers.overlays[layerName];\n        if (!(layerGroup instanceof L.LayerGroup || layerGroup instanceof L.FeatureGroup)) {\n            $log.error(errorHeader + ' Adding a marker to an overlay needs a overlay of the type \"group\" or \"featureGroup\"');\n            return false;\n        }\n\n        // The marker goes to a correct layer group, so first of all we add it\n        layerGroup.addLayer(marker);\n\n        // The marker is automatically added to the map depending on the visibility\n        // of the layer, so we only have to open the popup if the marker is in the map\n        if (!doIndividualWatch && map.hasLayer(marker) && model.focus === true) {\n            marker.openPopup();\n        }\n        return true;\n    };\n    //TODO: move to leafletMarkersHelpers??? or make a new class/function file (leafletMarkersHelpers is large already)\n    var _addMarkers = function(mapId, markersToRender, oldModels, map, layers, leafletMarkers, leafletScope,\n                               watchOptions, maybeLayerName, skips){\n        for (var newName in markersToRender) {\n            if(skips[newName])\n                continue;\n\n            if (newName.search(\"-\") !== -1) {\n                $log.error('The marker can\\'t use a \"-\" on his key name: \"' + newName + '\".');\n                continue;\n            }\n\n            var model = Helpers.copy(markersToRender[newName]);\n            var pathToMarker = Helpers.getObjectDotPath(maybeLayerName? [maybeLayerName, newName]: [newName]);\n            var maybeLMarker = _getLMarker(leafletMarkers,newName, maybeLayerName);\n            if (!isDefined(maybeLMarker)) {\n                //(nmccready) very important to not have model changes when lObject is changed\n                //this might be desirable in some cases but it causes two-way binding to lObject which is not ideal\n                //if it is left as the reference then all changes from oldModel vs newModel are ignored\n                //see _destroy (where modelDiff becomes meaningless if we do not copy here)\n                var marker = createMarker(model);\n                var layerName = (model? model.layer : undefined) || maybeLayerName; //original way takes pref\n                if (!isDefined(marker)) {\n                    $log.error(errorHeader + ' Received invalid data on the marker ' + newName + '.');\n                    continue;\n                }\n                _setLMarker(marker, leafletMarkers, newName, maybeLayerName);\n\n                // Bind message\n                if (isDefined(model.message)) {\n                    marker.bindPopup(model.message, model.popupOptions);\n                }\n\n                // Add the marker to a cluster group if needed\n                if (isDefined(model.group)) {\n                    var groupOptions = isDefined(model.groupOption) ? model.groupOption : null;\n                    addMarkerToGroup(marker, model.group, groupOptions, map);\n                }\n\n                // Show label if defined\n                if (Helpers.LabelPlugin.isLoaded() && isDefined(model.label) && isDefined(model.label.message)) {\n                    marker.bindLabel(model.label.message, model.label.options);\n                }\n\n                // Check if the marker should be added to a layer\n                if (isDefined(model) && (isDefined(model.layer) || isDefined(maybeLayerName))){\n\n                    var pass = _maybeAddMarkerToLayer(layerName, layers, model, marker,\n                        watchOptions.individual.doWatch, map);\n                    if(!pass)\n                        continue; //something went wrong move on in the loop\n                } else if (!isDefined(model.group)) {\n                    // We do not have a layer attr, so the marker goes to the map layer\n                    map.addLayer(marker);\n                    if (!watchOptions.individual.doWatch && model.focus === true) {\n                        marker.openPopup();\n                    }\n                }\n\n                if (watchOptions.individual.doWatch) {\n                    addMarkerWatcher(marker, pathToMarker, leafletScope, layers, map,\n                        watchOptions.individual.isDeep);\n                }\n\n                listenMarkerEvents(marker, model, leafletScope, watchOptions.individual.doWatch, map);\n                leafletMarkerEvents.bindEvents(mapId, marker, pathToMarker, model, leafletScope, layerName);\n            }\n            else {\n                var oldModel = isDefined(oldModel)? oldModels[newName] : undefined;\n                updateMarker(model, oldModel, maybeLMarker, pathToMarker, leafletScope, layers, map);\n            }\n        }\n    };\n    var _seeWhatWeAlreadyHave = function(markerModels, oldMarkerModels, lMarkers, isEqual, cb){\n        var hasLogged = false,\n            equals = false,\n            oldMarker,\n            newMarker;\n\n        var doCheckOldModel =  isDefined(oldMarkerModels);\n        for (var name in lMarkers) {\n            if(!hasLogged) {\n                $log.debug(errorHeader + \"[markers] destroy: \");\n                hasLogged = true;\n            }\n\n            if(doCheckOldModel){\n                //might want to make the option (in watch options) to disable deep checking\n                //ie the options to only check !== (reference check) instead of angular.equals (slow)\n                newMarker = markerModels[name];\n                oldMarker = oldMarkerModels[name];\n                equals = angular.equals(newMarker,oldMarker) && isEqual;\n            }\n            if (!isDefined(markerModels) ||\n                !Object.keys(markerModels).length ||\n                !isDefined(markerModels[name]) ||\n                !Object.keys(markerModels[name]).length ||\n                equals) {\n                if(cb && Helpers.isFunction(cb))\n                    cb(newMarker, oldMarker, name);\n            }\n        }\n    };\n    var _destroy = function(markerModels, oldMarkerModels, lMarkers, map, layers){\n        _seeWhatWeAlreadyHave(markerModels, oldMarkerModels, lMarkers, false,\n            function(newMarker, oldMarker, lMarkerName){\n                $log.debug(errorHeader + '[marker] is deleting marker: ' + lMarkerName);\n                deleteMarker(lMarkers[lMarkerName], map, layers);\n                delete lMarkers[lMarkerName];\n            });\n    };\n\n    var _getNewModelsToSkipp =  function(newModels, oldModels, lMarkers){\n        var skips = {};\n        _seeWhatWeAlreadyHave(newModels, oldModels, lMarkers, true,\n            function(newMarker, oldMarker, lMarkerName){\n                $log.debug(errorHeader + '[marker] is already rendered, marker: ' + lMarkerName);\n                skips[lMarkerName] = newMarker;\n            });\n        return skips;\n    };\n\n    return {\n        restrict: \"A\",\n        scope: false,\n        replace: false,\n        require: ['leaflet', '?layers'],\n\n        link: function(scope, element, attrs, controller) {\n            var mapController = controller[0],\n                leafletScope  = mapController.getLeafletScope();\n\n            mapController.getMap().then(function(map) {\n                var leafletMarkers = {}, getLayers;\n\n                // If the layers attribute is used, we must wait until the layers are created\n                if (isDefined(controller[1])) {\n                    getLayers = controller[1].getLayers;\n                } else {\n                    getLayers = function() {\n                        var deferred = $q.defer();\n                        deferred.resolve();\n                        return deferred.promise;\n                    };\n                }\n\n                var watchOptions = leafletScope.markersWatchOptions || _markersWatchOptions;\n\n                // backwards compat\n                if(isDefined(attrs.watchMarkers))\n                    watchOptions.doWatch = watchOptions.individual.doWatch =\n                        (!isDefined(attrs.watchMarkers) || Helpers.isTruthy(attrs.watchMarkers));\n\n                var isNested = (isDefined(attrs.markersNested) && Helpers.isTruthy(attrs.markersNested));\n\n                getLayers().then(function(layers) {\n                    var _clean = function(models, oldModels){\n                        if(isNested) {\n                            $it.each(models, function(markerToMaybeDel, layerName) {\n                                var oldModel = isDefined(oldModel)? oldModels[layerName] : undefined;\n                                _destroy(markerToMaybeDel, oldModel, leafletMarkers[layerName], map, layers);\n                            });\n                            return;\n                        }\n                        _destroy(models, oldModels, leafletMarkers, map, layers);\n                    };\n\n                    var _create = function(models, oldModels){\n                        _clean(models, oldModels);\n                        var skips = null;\n                        if(isNested) {\n                            $it.each(models, function(markersToAdd, layerName) {\n                                var oldModel = isDefined(oldModel)? oldModels[layerName] : undefined;\n                                skips = _getNewModelsToSkipp(models[layerName], oldModel, leafletMarkers[layerName]);\n                                _addMarkers(attrs.id, markersToAdd, oldModels, map, layers, leafletMarkers, leafletScope,\n                                    watchOptions, layerName, skips);\n                            });\n                            return;\n                        }\n                        skips = _getNewModelsToSkipp(models, oldModels, leafletMarkers);\n                        _addMarkers(attrs.id, models, oldModels, map, layers, leafletMarkers, leafletScope,\n                            watchOptions, undefined, skips);\n                    };\n                    extendDirectiveControls(attrs.id, 'markers', _create, _clean);\n                    leafletData.setMarkers(leafletMarkers, attrs.id);\n\n                    maybeWatch(leafletScope,'markers', watchOptions, function(newMarkers, oldMarkers){\n                        _create(newMarkers, oldMarkers);\n                    });\n                });\n            });\n        }\n    };\n}]);\n\nangular.module(\"leaflet-directive\").directive('maxbounds', [\"$log\", \"leafletMapDefaults\", \"leafletBoundsHelpers\", \"leafletHelpers\", function ($log, leafletMapDefaults, leafletBoundsHelpers, leafletHelpers) {\n\n    return {\n        restrict: \"A\",\n        scope: false,\n        replace: false,\n        require: 'leaflet',\n\n        link: function(scope, element, attrs, controller) {\n            var leafletScope  = controller.getLeafletScope(),\n                isValidBounds = leafletBoundsHelpers.isValidBounds,\n                isNumber = leafletHelpers.isNumber;\n\n\n            controller.getMap().then(function(map) {\n                leafletScope.$watch(\"maxbounds\", function (maxbounds) {\n                    if (!isValidBounds(maxbounds)) {\n                        // Unset any previous maxbounds\n                        map.setMaxBounds();\n                        return;\n                    }\n\n                    var leafletBounds = leafletBoundsHelpers.createLeafletBounds(maxbounds);\n                    if(isNumber(maxbounds.pad)) {\n                      leafletBounds = leafletBounds.pad(maxbounds.pad);\n                    }\n\n                    map.setMaxBounds(leafletBounds);\n                    if (!attrs.center && !attrs.lfCenter) {\n                        map.fitBounds(leafletBounds);\n                    }\n                });\n            });\n        }\n    };\n}]);\n\nangular.module(\"leaflet-directive\").directive('paths', [\"$log\", \"$q\", \"leafletData\", \"leafletMapDefaults\", \"leafletHelpers\", \"leafletPathsHelpers\", \"leafletPathEvents\", function ($log, $q, leafletData, leafletMapDefaults, leafletHelpers, leafletPathsHelpers, leafletPathEvents) {\n\n    return {\n        restrict: \"A\",\n        scope: false,\n        replace: false,\n        require: ['leaflet', '?layers'],\n\n        link: function(scope, element, attrs, controller) {\n            var mapController = controller[0],\n                isDefined = leafletHelpers.isDefined,\n                isString = leafletHelpers.isString,\n                leafletScope  = mapController.getLeafletScope(),\n                paths     = leafletScope.paths,\n                createPath = leafletPathsHelpers.createPath,\n                bindPathEvents = leafletPathEvents.bindPathEvents,\n                setPathOptions = leafletPathsHelpers.setPathOptions;\n\n            mapController.getMap().then(function(map) {\n                var defaults = leafletMapDefaults.getDefaults(attrs.id),\n                    getLayers;\n\n                // If the layers attribute is used, we must wait until the layers are created\n                if (isDefined(controller[1])) {\n                    getLayers = controller[1].getLayers;\n                } else {\n                    getLayers = function() {\n                        var deferred = $q.defer();\n                        deferred.resolve();\n                        return deferred.promise;\n                    };\n                }\n\n                if (!isDefined(paths)) {\n                    return;\n                }\n\n                getLayers().then(function(layers) {\n\n                    var leafletPaths = {};\n                    leafletData.setPaths(leafletPaths, attrs.id);\n\n                    // Should we watch for every specific marker on the map?\n                    var shouldWatch = (!isDefined(attrs.watchPaths) || attrs.watchPaths === 'true');\n\n                    // Function for listening every single path once created\n                    var watchPathFn = function(leafletPath, name) {\n                        var clearWatch = leafletScope.$watch(\"paths[\\\"\"+name+\"\\\"]\", function(pathData, old) {\n                            if (!isDefined(pathData)) {\n                                if (isDefined(old.layer)) {\n                                    for (var i in layers.overlays) {\n                                        var overlay = layers.overlays[i];\n                                        overlay.removeLayer(leafletPath);\n                                    }\n                                }\n                                map.removeLayer(leafletPath);\n                                clearWatch();\n                                return;\n                            }\n                            setPathOptions(leafletPath, pathData.type, pathData);\n                        }, true);\n                    };\n\n                    leafletScope.$watchCollection(\"paths\", function (newPaths) {\n\n                        // Delete paths (by name) from the array\n                        for (var name in leafletPaths) {\n                            if (!isDefined(newPaths[name])) {\n                                map.removeLayer(leafletPaths[name]);\n                                delete leafletPaths[name];\n                            }\n                        }\n\n                        // Create the new paths\n                        for (var newName in newPaths) {\n                            if (newName.search('\\\\$') === 0) {\n                                continue;\n                            }\n                            if (newName.search(\"-\") !== -1) {\n                                $log.error('[AngularJS - Leaflet] The path name \"' + newName + '\" is not valid. It must not include \"-\" and a number.');\n                                continue;\n                            }\n\n                            if (!isDefined(leafletPaths[newName])) {\n                                var pathData = newPaths[newName];\n                                var newPath = createPath(newName, newPaths[newName], defaults);\n\n                                // bind popup if defined\n                                if (isDefined(newPath) && isDefined(pathData.message)) {\n                                    newPath.bindPopup(pathData.message, pathData.popupOptions);\n                                }\n\n                                // Show label if defined\n                                if (leafletHelpers.LabelPlugin.isLoaded() && isDefined(pathData.label) && isDefined(pathData.label.message)) {\n                                    newPath.bindLabel(pathData.label.message, pathData.label.options);\n                                }\n\n                                // Check if the marker should be added to a layer\n                                if (isDefined(pathData) && isDefined(pathData.layer)) {\n\n                                    if (!isString(pathData.layer)) {\n                                        $log.error('[AngularJS - Leaflet] A layername must be a string');\n                                        continue;\n                                    }\n                                    if (!isDefined(layers)) {\n                                        $log.error('[AngularJS - Leaflet] You must add layers to the directive if the markers are going to use this functionality.');\n                                        continue;\n                                    }\n\n                                    if (!isDefined(layers.overlays) || !isDefined(layers.overlays[pathData.layer])) {\n                                        $log.error('[AngularJS - Leaflet] A path can only be added to a layer of type \"group\"');\n                                        continue;\n                                    }\n                                    var layerGroup = layers.overlays[pathData.layer];\n                                    if (!(layerGroup instanceof L.LayerGroup || layerGroup instanceof L.FeatureGroup)) {\n                                        $log.error('[AngularJS - Leaflet] Adding a path to an overlay needs a overlay of the type \"group\" or \"featureGroup\"');\n                                        continue;\n                                    }\n\n                                    // Listen for changes on the new path\n                                    leafletPaths[newName] = newPath;\n                                    // The path goes to a correct layer group, so first of all we add it\n                                    layerGroup.addLayer(newPath);\n\n                                    if (shouldWatch) {\n                                        watchPathFn(newPath, newName);\n                                    } else {\n                                        setPathOptions(newPath, pathData.type, pathData);\n                                    }\n                                } else if (isDefined(newPath)) {\n                                    // Listen for changes on the new path\n                                    leafletPaths[newName] = newPath;\n                                    map.addLayer(newPath);\n\n                                    if (shouldWatch) {\n                                        watchPathFn(newPath, newName);\n                                    } else {\n                                        setPathOptions(newPath, pathData.type, pathData);\n                                    }\n                                }\n\n                                bindPathEvents(attrs.id, newPath, newName, pathData, leafletScope);\n                            }\n                        }\n                    });\n                });\n            });\n        }\n    };\n}]);\n\nangular.module(\"leaflet-directive\").directive('tiles', [\"$log\", \"leafletData\", \"leafletMapDefaults\", \"leafletHelpers\", function ($log, leafletData, leafletMapDefaults, leafletHelpers) {\n\n    return {\n        restrict: \"A\",\n        scope: false,\n        replace: false,\n        require: 'leaflet',\n\n        link: function(scope, element, attrs, controller) {\n            var isDefined = leafletHelpers.isDefined,\n                leafletScope  = controller.getLeafletScope(),\n                tiles = leafletScope.tiles;\n\n            if (!isDefined(tiles) ||  !isDefined(tiles.url)) {\n                $log.warn(\"[AngularJS - Leaflet] The 'tiles' definition doesn't have the 'url' property.\");\n                return;\n            }\n\n            controller.getMap().then(function(map) {\n                var defaults = leafletMapDefaults.getDefaults(attrs.id);\n                var tileLayerObj;\n                leafletScope.$watch(\"tiles\", function(tiles, oldtiles) {\n                    var tileLayerOptions = defaults.tileLayerOptions;\n                    var tileLayerUrl = defaults.tileLayer;\n\n                    // If no valid tiles are in the scope, remove the last layer\n                    if (!isDefined(tiles.url) && isDefined(tileLayerObj)) {\n                        map.removeLayer(tileLayerObj);\n                        return;\n                    }\n\n                    // No leafletTiles object defined yet\n                    if (!isDefined(tileLayerObj)) {\n                        if (isDefined(tiles.options)) {\n                            angular.copy(tiles.options, tileLayerOptions);\n                        }\n\n                        if (isDefined(tiles.url)) {\n                            tileLayerUrl = tiles.url;\n                        }\n\n                        if (tiles.type === 'wms') {\n                            tileLayerObj = L.tileLayer.wms(tileLayerUrl, tileLayerOptions);\n                        } else {\n                            tileLayerObj = L.tileLayer(tileLayerUrl, tileLayerOptions);\n                        }\n\n                        tileLayerObj.addTo(map);\n                        leafletData.setTiles(tileLayerObj, attrs.id);\n                        return;\n                    }\n\n                    // If the options of the tilelayer is changed, we need to redraw the layer\n                    if (isDefined(tiles.url) && isDefined(tiles.options) &&\n                        (tiles.type !== oldtiles.type || !angular.equals(tiles.options, tileLayerOptions))) {\n                        map.removeLayer(tileLayerObj);\n                        tileLayerOptions = defaults.tileLayerOptions;\n                        angular.copy(tiles.options, tileLayerOptions);\n                        tileLayerUrl = tiles.url;\n\n                        if (tiles.type === 'wms') {\n                            tileLayerObj = L.tileLayer.wms(tileLayerUrl, tileLayerOptions);\n                        } else {\n                            tileLayerObj = L.tileLayer(tileLayerUrl, tileLayerOptions);\n                        }\n\n                        tileLayerObj.addTo(map);\n                        leafletData.setTiles(tileLayerObj, attrs.id);\n                        return;\n                    }\n\n                    // Only the URL of the layer is changed, update the tiles object\n                    if (isDefined(tiles.url)) {\n                        tileLayerObj.setUrl(tiles.url);\n                    }\n                }, true);\n            });\n        }\n    };\n}]);\n\n/*\n    Create multiple similar directives for watchOptions to support directiveControl\n    instead. (when watches are disabled)\n    NgAnnotate does not work here due to the functional creation\n*/\n['markers', 'geojson'].forEach(function(name){\n    angular.module(\"leaflet-directive\").directive(name + 'WatchOptions', [\n        '$log', '$rootScope', '$q', 'leafletData', 'leafletHelpers',\n        function ($log, $rootScope, $q, leafletData, leafletHelpers) {\n\n            var isDefined = leafletHelpers.isDefined,\n                errorHeader = leafletHelpers.errorHeader,\n                isObject = leafletHelpers.isObject,\n                _watchOptions = leafletHelpers.watchOptions;\n\n            return {\n                restrict: \"A\",\n                scope: false,\n                replace: false,\n                require: ['leaflet'],\n\n                link: function (scope, element, attrs, controller) {\n                    var mapController = controller[0],\n                        leafletScope = mapController.getLeafletScope();\n\n                    mapController.getMap().then(function () {\n                        if (isDefined(scope[name + 'WatchOptions'])) {\n                            if (isObject(scope[name + 'WatchOptions']))\n                                angular.extend(_watchOptions, scope[name + 'WatchOptions']);\n                            else\n                                $log.error(errorHeader + '[' + name + 'WatchOptions] is not an object');\n                            leafletScope[name + 'WatchOptions'] = _watchOptions;\n                        }\n                    });\n                }\n            };\n    }]);\n});\n\nangular.module(\"leaflet-directive\")\n.factory('leafletEventsHelpersFactory', [\"$rootScope\", \"$q\", \"$log\", \"leafletHelpers\", function ($rootScope, $q, $log, leafletHelpers) {\n        var safeApply = leafletHelpers.safeApply,\n            isDefined = leafletHelpers.isDefined,\n            isObject = leafletHelpers.isObject,\n            isArray = leafletHelpers.isArray,\n            errorHeader = leafletHelpers.errorHeader;\n\n        var EventsHelper = function(rootBroadcastName, lObjectType){\n            this.rootBroadcastName = rootBroadcastName;\n            $log.debug(\"leafletEventsHelpersFactory: lObjectType: \" + lObjectType + \"rootBroadcastName: \" + rootBroadcastName);\n            //used to path/key out certain properties based on the type , \"markers\", \"geojson\"\n            this.lObjectType = lObjectType;\n        };\n\n        EventsHelper.prototype.getAvailableEvents = function(){return [];};\n\n        /*\n         argument: name: Note this can be a single string or dot notation\n         Example:\n         markerModel : {\n         m1: { lat:_, lon: _}\n         }\n         //would yield name of\n         name = \"m1\"\n\n         If nested:\n         markerModel : {\n         cars: {\n         m1: { lat:_, lon: _}\n         }\n         }\n         //would yield name of\n         name = \"cars.m1\"\n         */\n        EventsHelper.prototype.genDispatchEvent = function(maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName, extra) {\n            var _this = this;\n\n            maybeMapId = maybeMapId || '';\n            if (maybeMapId)\n              maybeMapId = '.' + maybeMapId;\n\n            return function (e) {\n                var broadcastName = _this.rootBroadcastName + maybeMapId + '.' + eventName;\n                $log.debug(broadcastName);\n                _this.fire(leafletScope, broadcastName, logic, e, e.target || lObject, model, name, layerName, extra);\n            };\n        };\n\n        EventsHelper.prototype.fire = function(scope, broadcastName, logic, event, lObject, model, modelName, layerName, extra){\n            // Safely broadcast the event\n            safeApply(scope, function(){\n                var toSend = {\n                    leafletEvent: event,\n                    leafletObject: lObject,\n                    modelName: modelName,\n                    model: model\n                };\n                if (isDefined(layerName))\n                    angular.extend(toSend, {layerName: layerName});\n\n                if (logic === \"emit\") {\n                  scope.$emit(broadcastName, toSend);\n                } else {\n                    $rootScope.$broadcast(broadcastName, toSend);\n                }\n            });\n        };\n\n        EventsHelper.prototype.bindEvents = function (maybeMapId, lObject, name, model, leafletScope, layerName, extra) {\n            var events = [];\n            var logic = 'emit';\n            var _this = this;\n\n            if (!isDefined(leafletScope.eventBroadcast)) {\n                // Backward compatibility, if no event-broadcast attribute, all events are broadcasted\n                events = this.getAvailableEvents();\n            } else if (!isObject(leafletScope.eventBroadcast)) {\n                // Not a valid object\n                $log.error(errorHeader + \"event-broadcast must be an object check your model.\");\n            } else {\n                // We have a possible valid object\n                if (!isDefined(leafletScope.eventBroadcast[_this.lObjectType])) {\n                    // We do not have events enable/disable do we do nothing (all enabled by default)\n                    events = this.getAvailableEvents();\n                } else if (!isObject(leafletScope.eventBroadcast[_this.lObjectType])) {\n                    // Not a valid object\n                    $log.warn(errorHeader + 'event-broadcast.' + [_this.lObjectType]  + ' must be an object check your model.');\n                } else {\n                    // We have a possible valid map object\n                    // Event propadation logic\n                    if (isDefined(leafletScope.eventBroadcast[this.lObjectType].logic)) {\n                        // We take care of possible propagation logic\n                        if (leafletScope.eventBroadcast[_this.lObjectType].logic !== \"emit\" &&\n                            leafletScope.eventBroadcast[_this.lObjectType].logic !== \"broadcast\")\n                                $log.warn(errorHeader + \"Available event propagation logic are: 'emit' or 'broadcast'.\");\n                    }\n                    // Enable / Disable\n                    var eventsEnable = false, eventsDisable = false;\n                    if (isDefined(leafletScope.eventBroadcast[_this.lObjectType].enable) &&\n                        isArray(leafletScope.eventBroadcast[_this.lObjectType].enable))\n                            eventsEnable = true;\n                    if (isDefined(leafletScope.eventBroadcast[_this.lObjectType].disable) &&\n                        isArray(leafletScope.eventBroadcast[_this.lObjectType].disable))\n                            eventsDisable = true;\n\n                    if (eventsEnable && eventsDisable) {\n                        // Both are active, this is an error\n                        $log.warn(errorHeader + \"can not enable and disable events at the same time\");\n                    } else if (!eventsEnable && !eventsDisable) {\n                        // Both are inactive, this is an error\n                        $log.warn(errorHeader + \"must enable or disable events\");\n                    } else {\n                        // At this point the object is OK, lets enable or disable events\n                        if (eventsEnable) {\n                            // Enable events\n                            leafletScope.eventBroadcast[this.lObjectType].enable.forEach(function(eventName){\n                                // Do we have already the event enabled?\n                                if (events.indexOf(eventName) !== -1) {\n                                    // Repeated event, this is an error\n                                    $log.warn(errorHeader + \"This event \" + eventName + \" is already enabled\");\n                                } else {\n                                    // Does the event exists?\n                                    if (_this.getAvailableEvents().indexOf(eventName) === -1) {\n                                        // The event does not exists, this is an error\n                                        $log.warn(errorHeader + \"This event \" + eventName + \" does not exist\");\n                                    } else {\n                                        // All ok enable the event\n                                        events.push(eventName);\n                                    }\n                                }\n                            });\n                        } else {\n                            // Disable events\n                            events = this.getAvailableEvents();\n                            leafletScope.eventBroadcast[_this.lObjectType].disable.forEach(function(eventName) {\n                                var index = events.indexOf(eventName);\n                                if (index === -1) {\n                                    // The event does not exist\n                                    $log.warn(errorHeader + \"This event \" + eventName + \" does not exist or has been already disabled\");\n\n                                } else {\n                                    events.splice(index, 1);\n                                }\n                            });\n                        }\n                    }\n                }\n            }\n\n            events.forEach(function(eventName){\n                lObject.on(eventName,_this.genDispatchEvent(maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName, extra));\n            });\n          return logic;\n        };\n\n        return EventsHelper;\n}])\n.service('leafletEventsHelpers', [\"leafletEventsHelpersFactory\", function(leafletEventsHelpersFactory){\n    return new leafletEventsHelpersFactory();\n}]);\n\nangular.module(\"leaflet-directive\")\n.factory('leafletGeoJsonEvents', [\"$rootScope\", \"$q\", \"$log\", \"leafletHelpers\", \"leafletEventsHelpersFactory\", \"leafletData\", function ($rootScope, $q, $log, leafletHelpers,\n  leafletEventsHelpersFactory, leafletData) {\n    var safeApply = leafletHelpers.safeApply,\n        EventsHelper = leafletEventsHelpersFactory;\n\n    var GeoJsonEvents = function(){\n      EventsHelper.call(this,'leafletDirectiveGeoJson', 'geojson');\n    };\n\n    GeoJsonEvents.prototype =  new EventsHelper();\n\n    GeoJsonEvents.prototype.genDispatchEvent = function(maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName, extra) {\n        var base = EventsHelper.prototype.genDispatchEvent.call(this, maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName),\n        _this = this;\n\n        return function(e){\n            if (eventName === 'mouseout') {\n                if (extra.resetStyleOnMouseout) {\n                    leafletData.getGeoJSON(extra.mapId)\n                    .then(function(leafletGeoJSON){\n                        //this is broken on nested needs to traverse or user layerName (nested)\n                        var lobj = layerName? leafletGeoJSON[layerName]: leafletGeoJSON;\n                        lobj.resetStyle(e.target);\n                    });\n\n                }\n                safeApply(leafletScope, function() {\n                    $rootScope.$broadcast(_this.rootBroadcastName + '.mouseout', e);\n                });\n            }\n            base(e); //common\n        };\n    };\n\n    GeoJsonEvents.prototype.getAvailableEvents = function(){ return [\n        'click',\n        'dblclick',\n        'mouseover',\n        'mouseout',\n        ];\n    };\n\n    return new GeoJsonEvents();\n}]);\n\nangular.module(\"leaflet-directive\")\n.factory('leafletLabelEvents', [\"$rootScope\", \"$q\", \"$log\", \"leafletHelpers\", \"leafletEventsHelpersFactory\", function ($rootScope, $q, $log, leafletHelpers, leafletEventsHelpersFactory) {\n    var Helpers = leafletHelpers,\n        EventsHelper = leafletEventsHelpersFactory;\n\n        var LabelEvents = function(){\n          EventsHelper.call(this,'leafletDirectiveLabel', 'markers');\n        };\n        LabelEvents.prototype =  new EventsHelper();\n\n        LabelEvents.prototype.genDispatchEvent = function(maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName) {\n            var markerName = name.replace('markers.', '');\n            return EventsHelper.prototype\n                .genDispatchEvent.call(this, maybeMapId, eventName, logic, leafletScope, lObject, markerName, model, layerName);\n        };\n\n        LabelEvents.prototype.getAvailableEvents = function(){\n            return [\n                'click',\n                'dblclick',\n                'mousedown',\n                'mouseover',\n                'mouseout',\n                'contextmenu'\n            ];\n        };\n\n        LabelEvents.prototype.genEvents = function (maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName) {\n            var _this = this;\n            var labelEvents = this.getAvailableEvents();\n            var scopeWatchName = Helpers.getObjectArrayPath(\"markers.\" + name);\n            labelEvents.forEach(function(eventName) {\n                lObject.label.on(eventName, _this.genDispatchEvent(\n                    maybeMapId, eventName, logic, leafletScope, lObject.label, scopeWatchName, model, layerName));\n            });\n        };\n\n        LabelEvents.prototype.bindEvents = function (maybeMapId, lObject, name, model, leafletScope, layerName) {};\n\n        return new LabelEvents();\n}]);\n\nangular.module(\"leaflet-directive\")\n.factory('leafletMapEvents', [\"$rootScope\", \"$q\", \"$log\", \"leafletHelpers\", \"leafletEventsHelpers\", \"leafletIterators\", function ($rootScope, $q, $log, leafletHelpers, leafletEventsHelpers, leafletIterators) {\n    var isDefined = leafletHelpers.isDefined,\n        fire = leafletEventsHelpers.fire;\n\n    var _getAvailableMapEvents = function() {\n        return [\n            'click',\n            'dblclick',\n            'mousedown',\n            'mouseup',\n            'mouseover',\n            'mouseout',\n            'mousemove',\n            'contextmenu',\n            'focus',\n            'blur',\n            'preclick',\n            'load',\n            'unload',\n            'viewreset',\n            'movestart',\n            'move',\n            'moveend',\n            'dragstart',\n            'drag',\n            'dragend',\n            'zoomstart',\n            'zoomanim',\n            'zoomend',\n            'zoomlevelschange',\n            'resize',\n            'autopanstart',\n            'layeradd',\n            'layerremove',\n            'baselayerchange',\n            'overlayadd',\n            'overlayremove',\n            'locationfound',\n            'locationerror',\n            'popupopen',\n            'popupclose',\n            'draw:created',\n            'draw:edited',\n            'draw:deleted',\n            'draw:drawstart',\n            'draw:drawstop',\n            'draw:editstart',\n            'draw:editstop',\n            'draw:deletestart',\n            'draw:deletestop'\n        ];\n    };\n\n    var _genDispatchMapEvent = function(scope, eventName, logic, maybeMapId) {\n        if (maybeMapId)\n          maybeMapId = maybeMapId + '.';\n        return function(e) {\n            // Put together broadcast name\n            var broadcastName = 'leafletDirectiveMap.' + maybeMapId + eventName;\n            $log.debug(broadcastName);\n            // Safely broadcast the event\n            fire(scope, broadcastName, logic, e, e.target, scope);\n        };\n    };\n\n    var _notifyCenterChangedToBounds = function(scope) {\n        scope.$broadcast(\"boundsChanged\");\n    };\n\n    var _notifyCenterUrlHashChanged = function(scope, map, attrs, search) {\n        if (!isDefined(attrs.urlHashCenter)) {\n            return;\n        }\n        var center = map.getCenter();\n        var centerUrlHash = (center.lat).toFixed(4) + \":\" + (center.lng).toFixed(4) + \":\" + map.getZoom();\n        if (!isDefined(search.c) || search.c !== centerUrlHash) {\n            //$log.debug(\"notified new center...\");\n            scope.$emit(\"centerUrlHash\", centerUrlHash);\n        }\n    };\n\n    var _addEvents =  function(map, mapEvents, contextName, scope, logic){\n        leafletIterators.each(mapEvents, function(eventName) {\n            var context = {};\n            context[contextName] = eventName;\n            map.on(eventName, _genDispatchMapEvent(scope, eventName, logic, map._container.id || ''), context);\n        });\n    };\n\n    return {\n        getAvailableMapEvents: _getAvailableMapEvents,\n        genDispatchMapEvent: _genDispatchMapEvent,\n        notifyCenterChangedToBounds: _notifyCenterChangedToBounds,\n        notifyCenterUrlHashChanged: _notifyCenterUrlHashChanged,\n        addEvents: _addEvents\n    };\n}]);\n\nangular.module(\"leaflet-directive\")\n.factory('leafletMarkerEvents', [\"$rootScope\", \"$q\", \"$log\", \"leafletHelpers\", \"leafletEventsHelpersFactory\", \"leafletLabelEvents\", function ($rootScope, $q, $log, leafletHelpers, leafletEventsHelpersFactory, leafletLabelEvents) {\n    var safeApply = leafletHelpers.safeApply,\n        isDefined = leafletHelpers.isDefined,\n        Helpers = leafletHelpers,\n        lblHelp = leafletLabelEvents,\n        EventsHelper = leafletEventsHelpersFactory;\n\n    var MarkerEvents = function(){\n      EventsHelper.call(this,'leafletDirectiveMarker', 'markers');\n    };\n\n    MarkerEvents.prototype = new EventsHelper();\n\n    MarkerEvents.prototype.genDispatchEvent = function(maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName) {\n        var handle = EventsHelper.prototype\n            .genDispatchEvent.call(this, maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName);\n        return function(e){\n            // Broadcast old marker click name for backwards compatibility\n            if (eventName === \"click\") {\n                safeApply(leafletScope, function () {\n                    $rootScope.$broadcast('leafletDirectiveMarkersClick', name);\n                });\n            } else if (eventName === 'dragend') {\n                safeApply(leafletScope, function () {\n                    model.lat = lObject.getLatLng().lat;\n                    model.lng = lObject.getLatLng().lng;\n                });\n                if (model.message && model.focus === true) {\n                    lObject.openPopup();\n                }\n            }\n            handle(e); //common\n        };\n    };\n\n    MarkerEvents.prototype.getAvailableEvents = function(){ return [\n        'click',\n        'dblclick',\n        'mousedown',\n        'mouseover',\n        'mouseout',\n        'contextmenu',\n        'dragstart',\n        'drag',\n        'dragend',\n        'move',\n        'remove',\n        'popupopen',\n        'popupclose',\n        'touchend',\n        'touchstart',\n        'touchmove',\n        'touchcancel',\n        'touchleave'\n        ];\n    };\n\n    MarkerEvents.prototype.bindEvents = function (maybeMapId, lObject, name, model, leafletScope, layerName) {\n      var logic = EventsHelper.prototype.bindEvents.call(this, maybeMapId, lObject, name, model, leafletScope, layerName);\n\n      if (Helpers.LabelPlugin.isLoaded() && isDefined(lObject.label)) {\n          lblHelp.genEvents(maybeMapId, name, logic, leafletScope, lObject, model, layerName);\n      }\n    };\n\n    return new MarkerEvents();\n}]);\n\nangular.module(\"leaflet-directive\")\n.factory('leafletPathEvents', [\"$rootScope\", \"$q\", \"$log\", \"leafletHelpers\", \"leafletLabelEvents\", \"leafletEventsHelpers\", function ($rootScope, $q, $log, leafletHelpers, leafletLabelEvents, leafletEventsHelpers) {\n    var isDefined = leafletHelpers.isDefined,\n        isObject = leafletHelpers.isObject,\n        Helpers = leafletHelpers,\n        errorHeader = leafletHelpers.errorHeader,\n        lblHelp = leafletLabelEvents,\n        fire = leafletEventsHelpers.fire;\n        \n    /*\n    TODO (nmccready) This EventsHelper needs to be derrived from leafletEventsHelpers to elminate copy and paste code.\n    */\n\n    var _genDispatchPathEvent = function (maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName) {\n        maybeMapId = maybeMapId || '';\n\n        if (maybeMapId)\n          maybeMapId = '.' + maybeMapId;\n\n        return function (e) {\n            var broadcastName = 'leafletDirectivePath' + maybeMapId + '.' + eventName;\n            $log.debug(broadcastName);\n            fire(leafletScope, broadcastName, logic, e, e.target || lObject, model, name, layerName);\n        };\n    };\n\n    var _bindPathEvents = function (maybeMapId, lObject, name, model, leafletScope) {\n        var pathEvents = [],\n            i,\n            eventName,\n            logic = \"broadcast\";\n\n        if (!isDefined(leafletScope.eventBroadcast)) {\n            // Backward compatibility, if no event-broadcast attribute, all events are broadcasted\n            pathEvents = _getAvailablePathEvents();\n        } else if (!isObject(leafletScope.eventBroadcast)) {\n            // Not a valid object\n            $log.error(errorHeader + \"event-broadcast must be an object check your model.\");\n        } else {\n            // We have a possible valid object\n            if (!isDefined(leafletScope.eventBroadcast.path)) {\n                // We do not have events enable/disable do we do nothing (all enabled by default)\n                pathEvents = _getAvailablePathEvents();\n            } else if (isObject(leafletScope.eventBroadcast.paths)) {\n                // Not a valid object\n                $log.warn(errorHeader + \"event-broadcast.path must be an object check your model.\");\n            } else {\n                // We have a possible valid map object\n                // Event propadation logic\n                if (leafletScope.eventBroadcast.path.logic !== undefined && leafletScope.eventBroadcast.path.logic !== null) {\n                    // We take care of possible propagation logic\n                    if (leafletScope.eventBroadcast.path.logic !== \"emit\" && leafletScope.eventBroadcast.path.logic !== \"broadcast\") {\n                        // This is an error\n                        $log.warn(errorHeader + \"Available event propagation logic are: 'emit' or 'broadcast'.\");\n                    } else if (leafletScope.eventBroadcast.path.logic === \"emit\") {\n                        logic = \"emit\";\n                    }\n                }\n                // Enable / Disable\n                var pathEventsEnable = false, pathEventsDisable = false;\n                if (leafletScope.eventBroadcast.path.enable !== undefined && leafletScope.eventBroadcast.path.enable !== null) {\n                    if (typeof leafletScope.eventBroadcast.path.enable === 'object') {\n                        pathEventsEnable = true;\n                    }\n                }\n                if (leafletScope.eventBroadcast.path.disable !== undefined && leafletScope.eventBroadcast.path.disable !== null) {\n                    if (typeof leafletScope.eventBroadcast.path.disable === 'object') {\n                        pathEventsDisable = true;\n                    }\n                }\n                if (pathEventsEnable && pathEventsDisable) {\n                    // Both are active, this is an error\n                    $log.warn(errorHeader + \"can not enable and disable events at the same time\");\n                } else if (!pathEventsEnable && !pathEventsDisable) {\n                    // Both are inactive, this is an error\n                    $log.warn(errorHeader + \"must enable or disable events\");\n                } else {\n                    // At this point the path object is OK, lets enable or disable events\n                    if (pathEventsEnable) {\n                        // Enable events\n                        for (i = 0; i < leafletScope.eventBroadcast.path.enable.length; i++) {\n                            eventName = leafletScope.eventBroadcast.path.enable[i];\n                            // Do we have already the event enabled?\n                            if (pathEvents.indexOf(eventName) !== -1) {\n                                // Repeated event, this is an error\n                                $log.warn(errorHeader + \"This event \" + eventName + \" is already enabled\");\n                            } else {\n                                // Does the event exists?\n                                if (_getAvailablePathEvents().indexOf(eventName) === -1) {\n                                    // The event does not exists, this is an error\n                                    $log.warn(errorHeader + \"This event \" + eventName + \" does not exist\");\n                                } else {\n                                    // All ok enable the event\n                                    pathEvents.push(eventName);\n                                }\n                            }\n                        }\n                    } else {\n                        // Disable events\n                        pathEvents = _getAvailablePathEvents();\n                        for (i = 0; i < leafletScope.eventBroadcast.path.disable.length; i++) {\n                            eventName = leafletScope.eventBroadcast.path.disable[i];\n                            var index = pathEvents.indexOf(eventName);\n                            if (index === -1) {\n                                // The event does not exist\n                                $log.warn(errorHeader + \"This event \" + eventName + \" does not exist or has been already disabled\");\n\n                            } else {\n                                pathEvents.splice(index, 1);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        for (i = 0; i < pathEvents.length; i++) {\n            eventName = pathEvents[i];\n            lObject.on(eventName, _genDispatchPathEvent(maybeMapId, eventName, logic, leafletScope, pathEvents, name));\n        }\n\n        if (Helpers.LabelPlugin.isLoaded() && isDefined(lObject.label)) {\n            lblHelp.genEvents(maybeMapId, name, logic, leafletScope, lObject, model);\n        }\n    };\n\n    var _getAvailablePathEvents = function () {\n        return [\n            'click',\n            'dblclick',\n            'mousedown',\n            'mouseover',\n            'mouseout',\n            'contextmenu',\n            'add',\n            'remove',\n            'popupopen',\n            'popupclose'\n        ];\n    };\n\n    return {\n        getAvailablePathEvents: _getAvailablePathEvents,\n        bindPathEvents: _bindPathEvents\n    };\n}]);\n\n}(angular));","/*\n * angucomplete-alt\n * Autocomplete directive for AngularJS\n * This is a fork of Daryl Rowland's angucomplete with some extra features.\n * By Hidenari Nozaki\n */\n\n/*! Copyright (c) 2014 Hidenari Nozaki and contributors | Licensed under the MIT license */\n\n'use strict';\n\n(function (root, factory) {\n  if (typeof module !== 'undefined' && module.exports) {\n    // CommonJS\n    module.exports = factory(require('angular'));\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(['angular'], factory);\n  } else {\n    // Global Variables\n    factory(root.angular);\n  }\n}(window, function (angular) {\n\n  angular.module('angucomplete-alt', []).directive('angucompleteAlt', ['$q', '$parse', '$http', '$sce', '$timeout', '$templateCache', '$interpolate', function ($q, $parse, $http, $sce, $timeout, $templateCache, $interpolate) {\n    // keyboard events\n    var KEY_DW  = 40;\n    var KEY_RT  = 39;\n    var KEY_UP  = 38;\n    var KEY_LF  = 37;\n    var KEY_ES  = 27;\n    var KEY_EN  = 13;\n    var KEY_TAB =  9;\n\n    var MIN_LENGTH = 3;\n    var MAX_LENGTH = 524288;  // the default max length per the html maxlength attribute\n    var PAUSE = 500;\n    var BLUR_TIMEOUT = 200;\n\n    // string constants\n    var REQUIRED_CLASS = 'autocomplete-required';\n    var TEXT_SEARCHING = 'Searching...';\n    var TEXT_NORESULTS = 'No results found';\n    var TEMPLATE_URL = '/angucomplete-alt/index.html';\n\n    // Set the default template for this directive\n    $templateCache.put(TEMPLATE_URL,\n        '<div class=\"angucomplete-holder\" ng-class=\"{\\'angucomplete-dropdown-visible\\': showDropdown}\">' +\n        '  <input id=\"{{id}}_value\" name=\"{{inputName}}\" ng-class=\"{\\'angucomplete-input-not-empty\\': notEmpty}\" ng-model=\"searchStr\" ng-disabled=\"disableInput\" type=\"{{inputType}}\" placeholder=\"{{placeholder}}\" maxlength=\"{{maxlength}}\" ng-focus=\"onFocusHandler()\" class=\"{{inputClass}}\" ng-focus=\"resetHideResults()\" ng-blur=\"hideResults($event)\" autocapitalize=\"off\" autocorrect=\"off\" autocomplete=\"off\" ng-change=\"inputChangeHandler(searchStr)\"/>' +\n        '  <div id=\"{{id}}_dropdown\" class=\"angucomplete-dropdown\" ng-show=\"showDropdown\">' +\n        '    <div class=\"angucomplete-searching\" ng-show=\"searching\" ng-bind=\"textSearching\"></div>' +\n        '    <div class=\"angucomplete-searching\" ng-show=\"!searching && (!results || results.length == 0)\" ng-bind=\"textNoResults\"></div>' +\n        '    <div class=\"angucomplete-row\" ng-repeat=\"result in results\" ng-click=\"selectResult(result)\" ng-mouseenter=\"hoverRow($index)\" ng-class=\"{\\'angucomplete-selected-row\\': $index == currentIndex}\">' +\n        '      <div ng-if=\"imageField\" class=\"angucomplete-image-holder\">' +\n        '        <img ng-if=\"result.image && result.image != \\'\\'\" ng-src=\"{{result.image}}\" class=\"angucomplete-image\"/>' +\n        '        <div ng-if=\"!result.image && result.image != \\'\\'\" class=\"angucomplete-image-default\"></div>' +\n        '      </div>' +\n        '      <div class=\"angucomplete-title\" ng-if=\"matchClass\" ng-bind-html=\"result.title\"></div>' +\n        '      <div class=\"angucomplete-title\" ng-if=\"!matchClass\">{{ result.title }}</div>' +\n        '      <div ng-if=\"matchClass && result.description && result.description != \\'\\'\" class=\"angucomplete-description\" ng-bind-html=\"result.description\"></div>' +\n        '      <div ng-if=\"!matchClass && result.description && result.description != \\'\\'\" class=\"angucomplete-description\">{{result.description}}</div>' +\n        '    </div>' +\n        '  </div>' +\n        '</div>'\n    );\n\n    function link(scope, elem, attrs, ctrl) {\n      var inputField = elem.find('input');\n      var minlength = MIN_LENGTH;\n      var searchTimer = null;\n      var hideTimer;\n      var requiredClassName = REQUIRED_CLASS;\n      var responseFormatter;\n      var validState = null;\n      var httpCanceller = null;\n      var dd = elem[0].querySelector('.angucomplete-dropdown');\n      var isScrollOn = false;\n      var mousedownOn = null;\n      var unbindInitialValue;\n      var displaySearching;\n      var displayNoResults;\n\n      elem.on('mousedown', function(event) {\n        if (event.target.id) {\n          mousedownOn = event.target.id;\n          if (mousedownOn === scope.id + '_dropdown') {\n            document.body.addEventListener('click', clickoutHandlerForDropdown);\n          }\n        }\n        else {\n          mousedownOn = event.target.className;\n        }\n      });\n\n      scope.currentIndex = scope.focusFirst ? 0 : null;\n      scope.searching = false;\n      unbindInitialValue = scope.$watch('initialValue', function(newval) {\n        if (newval) {\n          // remove scope listener\n          unbindInitialValue();\n          // change input\n          handleInputChange(newval, true);\n        }\n      });\n\n      scope.$watch('fieldRequired', function(newval, oldval) {\n        if (newval !== oldval) {\n          if (!newval) {\n            ctrl[scope.inputName].$setValidity(requiredClassName, true);\n          }\n          else if (!validState || scope.currentIndex === -1) {\n            handleRequired(false);\n          }\n          else {\n            handleRequired(true);\n          }\n        }\n      });\n\n      scope.$on('angucomplete-alt:clearInput', function (event, elementId) {\n        if (!elementId || elementId === scope.id) {\n          scope.searchStr = null;\n          callOrAssign();\n          handleRequired(false);\n          clearResults();\n        }\n      });\n\n      scope.$on('angucomplete-alt:changeInput', function (event, elementId, newval) {\n        if (!!elementId && elementId === scope.id) {\n          handleInputChange(newval);\n        }\n      });\n\n      function handleInputChange(newval, initial) {\n        if (newval) {\n          if (typeof newval === 'object') {\n            scope.searchStr = extractTitle(newval);\n            callOrAssign({originalObject: newval});\n          } else if (typeof newval === 'string' && newval.length > 0) {\n            scope.searchStr = newval;\n          } else {\n            if (console && console.error) {\n              console.error('Tried to set ' + (!!initial ? 'initial' : '') + ' value of angucomplete to', newval, 'which is an invalid value');\n            }\n          }\n\n          handleRequired(true);\n        }\n      }\n\n      // #194 dropdown list not consistent in collapsing (bug).\n      function clickoutHandlerForDropdown(event) {\n        mousedownOn = null;\n        scope.hideResults(event);\n        document.body.removeEventListener('click', clickoutHandlerForDropdown);\n      }\n\n      // for IE8 quirkiness about event.which\n      function ie8EventNormalizer(event) {\n        return event.which ? event.which : event.keyCode;\n      }\n\n      function callOrAssign(value) {\n        if (typeof scope.selectedObject === 'function') {\n          scope.selectedObject(value);\n        }\n        else {\n          scope.selectedObject = value;\n        }\n\n        if (value) {\n          handleRequired(true);\n        }\n        else {\n          handleRequired(false);\n        }\n      }\n\n      function callFunctionOrIdentity(fn) {\n        return function(data) {\n          return scope[fn] ? scope[fn](data) : data;\n        };\n      }\n\n      function setInputString(str) {\n        callOrAssign({originalObject: str});\n\n        if (scope.clearSelected) {\n          scope.searchStr = null;\n        }\n        clearResults();\n      }\n\n      function extractTitle(data) {\n        // split title fields and run extractValue for each and join with ' '\n        return scope.titleField.split(',')\n          .map(function(field) {\n            return extractValue(data, field);\n          })\n          .join(' ');\n      }\n\n      function extractValue(obj, key) {\n        var keys, result;\n        if (key) {\n          keys= key.split('.');\n          result = obj;\n          for (var i = 0; i < keys.length; i++) {\n            result = result[keys[i]];\n          }\n        }\n        else {\n          result = obj;\n        }\n        return result;\n      }\n\n      function findMatchString(target, str) {\n        var result, matches, re;\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\n        // Escape user input to be treated as a literal string within a regular expression\n        re = new RegExp(str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'i');\n        if (!target) { return; }\n        if (!target.match || !target.replace) { target = target.toString(); }\n        matches = target.match(re);\n        if (matches) {\n          result = target.replace(re,\n              '<span class=\"'+ scope.matchClass +'\">'+ matches[0] +'</span>');\n        }\n        else {\n          result = target;\n        }\n        return $sce.trustAsHtml(result);\n      }\n\n      function handleRequired(valid) {\n        scope.notEmpty = valid;\n        validState = scope.searchStr;\n        if (scope.fieldRequired && ctrl && scope.inputName) {\n          ctrl[scope.inputName].$setValidity(requiredClassName, valid);\n        }\n      }\n\n      function keyupHandler(event) {\n        var which = ie8EventNormalizer(event);\n        if (which === KEY_LF || which === KEY_RT) {\n          // do nothing\n          return;\n        }\n\n        if (which === KEY_UP || which === KEY_EN) {\n          event.preventDefault();\n        }\n        else if (which === KEY_DW) {\n          event.preventDefault();\n          if (!scope.showDropdown && scope.searchStr && scope.searchStr.length >= minlength) {\n            initResults();\n            scope.searching = true;\n            searchTimerComplete(scope.searchStr);\n          }\n        }\n        else if (which === KEY_ES) {\n          clearResults();\n          scope.$apply(function() {\n            inputField.val(scope.searchStr);\n          });\n        }\n        else {\n          if (minlength === 0 && !scope.searchStr) {\n            return;\n          }\n\n          if (!scope.searchStr || scope.searchStr === '') {\n            scope.showDropdown = false;\n          } else if (scope.searchStr.length >= minlength) {\n            initResults();\n\n            if (searchTimer) {\n              $timeout.cancel(searchTimer);\n            }\n\n            scope.searching = true;\n\n            searchTimer = $timeout(function() {\n              searchTimerComplete(scope.searchStr);\n            }, scope.pause);\n          }\n\n          if (validState && validState !== scope.searchStr && !scope.clearSelected) {\n            scope.$apply(function() {\n              callOrAssign();\n            });\n          }\n        }\n      }\n\n      function handleOverrideSuggestions(event) {\n        if (scope.overrideSuggestions &&\n            !(scope.selectedObject && scope.selectedObject.originalObject === scope.searchStr)) {\n          if (event) {\n            event.preventDefault();\n          }\n\n          // cancel search timer\n          $timeout.cancel(searchTimer);\n          // cancel http request\n          cancelHttpRequest();\n\n          setInputString(scope.searchStr);\n        }\n      }\n\n      function dropdownRowOffsetHeight(row) {\n        var css = getComputedStyle(row);\n        return row.offsetHeight +\n          parseInt(css.marginTop, 10) + parseInt(css.marginBottom, 10);\n      }\n\n      function dropdownHeight() {\n        return dd.getBoundingClientRect().top +\n          parseInt(getComputedStyle(dd).maxHeight, 10);\n      }\n\n      function dropdownRow() {\n        return elem[0].querySelectorAll('.angucomplete-row')[scope.currentIndex];\n      }\n\n      function dropdownRowTop() {\n        return dropdownRow().getBoundingClientRect().top -\n          (dd.getBoundingClientRect().top +\n           parseInt(getComputedStyle(dd).paddingTop, 10));\n      }\n\n      function dropdownScrollTopTo(offset) {\n        dd.scrollTop = dd.scrollTop + offset;\n      }\n\n      function updateInputField(){\n        var current = scope.results[scope.currentIndex];\n        if (scope.matchClass) {\n          inputField.val(extractTitle(current.originalObject));\n        }\n        else {\n          inputField.val(current.title);\n        }\n      }\n\n      function keydownHandler(event) {\n        var which = ie8EventNormalizer(event);\n        var row = null;\n        var rowTop = null;\n\n        if (which === KEY_EN && scope.results) {\n          if (scope.currentIndex >= 0 && scope.currentIndex < scope.results.length) {\n            event.preventDefault();\n            scope.selectResult(scope.results[scope.currentIndex]);\n          } else {\n            handleOverrideSuggestions(event);\n            clearResults();\n          }\n          scope.$apply();\n        } else if (which === KEY_DW && scope.results) {\n          event.preventDefault();\n          if ((scope.currentIndex + 1) < scope.results.length && scope.showDropdown) {\n            scope.$apply(function() {\n              scope.currentIndex ++;\n              updateInputField();\n            });\n\n            if (isScrollOn) {\n              row = dropdownRow();\n              if (dropdownHeight() < row.getBoundingClientRect().bottom) {\n                dropdownScrollTopTo(dropdownRowOffsetHeight(row));\n              }\n            }\n          }\n        } else if (which === KEY_UP && scope.results) {\n          event.preventDefault();\n          if (scope.currentIndex >= 1) {\n            scope.$apply(function() {\n              scope.currentIndex --;\n              updateInputField();\n            });\n\n            if (isScrollOn) {\n              rowTop = dropdownRowTop();\n              if (rowTop < 0) {\n                dropdownScrollTopTo(rowTop - 1);\n              }\n            }\n          }\n          else if (scope.currentIndex === 0) {\n            scope.$apply(function() {\n              scope.currentIndex = -1;\n              inputField.val(scope.searchStr);\n            });\n          }\n        } else if (which === KEY_TAB) {\n          if (scope.results && scope.results.length > 0 && scope.showDropdown) {\n            if (scope.currentIndex === -1 && scope.overrideSuggestions) {\n              // intentionally not sending event so that it does not\n              // prevent default tab behavior\n              handleOverrideSuggestions();\n            }\n            else {\n              if (scope.currentIndex === -1) {\n                scope.currentIndex = 0;\n              }\n              scope.selectResult(scope.results[scope.currentIndex]);\n              scope.$digest();\n            }\n          }\n          else {\n            // no results\n            // intentionally not sending event so that it does not\n            // prevent default tab behavior\n            if (scope.searchStr && scope.searchStr.length > 0) {\n              handleOverrideSuggestions();\n            }\n          }\n        } else if (which === KEY_ES) {\n          // This is very specific to IE10/11 #272\n          // without this, IE clears the input text\n          event.preventDefault();\n        }\n      }\n\n      function httpSuccessCallbackGen(str) {\n        return function(responseData, status, headers, config) {\n          // normalize return obejct from promise\n          if (!status && !headers && !config && responseData.data) {\n            responseData = responseData.data;\n          }\n          scope.searching = false;\n          processResults(\n            extractValue(responseFormatter(responseData), scope.remoteUrlDataField),\n            str);\n        };\n      }\n\n      function httpErrorCallback(errorRes, status, headers, config) {\n        // cancelled/aborted\n        if (status === 0 || status === -1) { return; }\n\n        // normalize return obejct from promise\n        if (!status && !headers && !config) {\n          status = errorRes.status;\n        }\n        if (scope.remoteUrlErrorCallback) {\n          scope.remoteUrlErrorCallback(errorRes, status, headers, config);\n        }\n        else {\n          if (console && console.error) {\n            console.error('http error');\n          }\n        }\n      }\n\n      function cancelHttpRequest() {\n        if (httpCanceller) {\n          httpCanceller.resolve();\n        }\n      }\n\n      function getRemoteResults(str) {\n        var params = {},\n            url = scope.remoteUrl + encodeURIComponent(str);\n        if (scope.remoteUrlRequestFormatter) {\n          params = {params: scope.remoteUrlRequestFormatter(str)};\n          url = scope.remoteUrl;\n        }\n        if (!!scope.remoteUrlRequestWithCredentials) {\n          params.withCredentials = true;\n        }\n        cancelHttpRequest();\n        httpCanceller = $q.defer();\n        params.timeout = httpCanceller.promise;\n        $http.get(url, params)\n          .success(httpSuccessCallbackGen(str))\n          .error(httpErrorCallback);\n      }\n\n      function getRemoteResultsWithCustomHandler(str) {\n        cancelHttpRequest();\n\n        httpCanceller = $q.defer();\n\n        scope.remoteApiHandler(str, httpCanceller.promise)\n          .then(httpSuccessCallbackGen(str))\n          .catch(httpErrorCallback);\n\n        /* IE8 compatible\n        scope.remoteApiHandler(str, httpCanceller.promise)\n          ['then'](httpSuccessCallbackGen(str))\n          ['catch'](httpErrorCallback);\n        */\n      }\n\n      function clearResults() {\n        scope.showDropdown = false;\n        scope.results = [];\n        if (dd) {\n          dd.scrollTop = 0;\n        }\n      }\n\n      function initResults() {\n        scope.showDropdown = displaySearching;\n        scope.currentIndex = scope.focusFirst ? 0 : -1;\n        scope.results = [];\n      }\n\n      function getLocalResults(str) {\n        var i, match, s, value,\n            searchFields = scope.searchFields.split(','),\n            matches = [];\n        if (typeof scope.parseInput() !== 'undefined') {\n          str = scope.parseInput()(str);\n        }\n        for (i = 0; i < scope.localData.length; i++) {\n          match = false;\n\n          for (s = 0; s < searchFields.length; s++) {\n            value = extractValue(scope.localData[i], searchFields[s]) || '';\n            match = match || (value.toString().toLowerCase().indexOf(str.toString().toLowerCase()) >= 0);\n          }\n\n          if (match) {\n            matches[matches.length] = scope.localData[i];\n          }\n        }\n\n        scope.searching = false;\n        processResults(matches, str);\n      }\n\n      function checkExactMatch(result, obj, str){\n        if (!str) { return false; }\n        for(var key in obj){\n          if(obj[key].toLowerCase() === str.toLowerCase()){\n            scope.selectResult(result);\n            return true;\n          }\n        }\n        return false;\n      }\n\n      function searchTimerComplete(str) {\n        // Begin the search\n        if (!str || str.length < minlength) {\n          return;\n        }\n        if (scope.localData) {\n          scope.$apply(function() {\n            getLocalResults(str);\n          });\n        }\n        else if (scope.remoteApiHandler) {\n          getRemoteResultsWithCustomHandler(str);\n        } else {\n          getRemoteResults(str);\n        }\n      }\n\n      function processResults(responseData, str) {\n        var i, description, image, text, formattedText, formattedDesc;\n\n        if (responseData && responseData.length > 0) {\n          scope.results = [];\n\n          for (i = 0; i < responseData.length; i++) {\n            if (scope.titleField && scope.titleField !== '') {\n              text = formattedText = extractTitle(responseData[i]);\n            }\n\n            description = '';\n            if (scope.descriptionField) {\n              description = formattedDesc = extractValue(responseData[i], scope.descriptionField);\n            }\n\n            image = '';\n            if (scope.imageField) {\n              image = extractValue(responseData[i], scope.imageField);\n            }\n\n            if (scope.matchClass) {\n              formattedText = findMatchString(text, str);\n              formattedDesc = findMatchString(description, str);\n            }\n\n            scope.results[scope.results.length] = {\n              title: formattedText,\n              description: formattedDesc,\n              image: image,\n              originalObject: responseData[i]\n            };\n          }\n\n        } else {\n          scope.results = [];\n        }\n\n        if (scope.autoMatch && scope.results.length === 1 &&\n            checkExactMatch(scope.results[0],\n              {title: text, desc: description || ''}, scope.searchStr)) {\n          scope.showDropdown = false;\n        } else if (scope.results.length === 0 && !displayNoResults) {\n          scope.showDropdown = false;\n        } else {\n          scope.showDropdown = true;\n        }\n      }\n\n      function showAll() {\n        if (scope.localData) {\n          processResults(scope.localData, '');\n        }\n        else if (scope.remoteApiHandler) {\n          getRemoteResultsWithCustomHandler('');\n        }\n        else {\n          getRemoteResults('');\n        }\n      }\n\n      scope.onFocusHandler = function() {\n        if (scope.focusIn) {\n          scope.focusIn();\n        }\n        if (minlength === 0 && (!scope.searchStr || scope.searchStr.length === 0)) {\n          scope.currentIndex = scope.focusFirst ? 0 : scope.currentIndex;\n          scope.showDropdown = true;\n          showAll();\n        }\n      };\n\n      scope.hideResults = function() {\n        if (mousedownOn &&\n            (mousedownOn === scope.id + '_dropdown' ||\n             mousedownOn.indexOf('angucomplete') >= 0)) {\n          mousedownOn = null;\n        }\n        else {\n          hideTimer = $timeout(function() {\n            clearResults();\n            scope.$apply(function() {\n              if (scope.searchStr && scope.searchStr.length > 0) {\n                inputField.val(scope.searchStr);\n              }\n            });\n          }, BLUR_TIMEOUT);\n          cancelHttpRequest();\n\n          if (scope.focusOut) {\n            scope.focusOut();\n          }\n\n          if (scope.overrideSuggestions) {\n            if (scope.searchStr && scope.searchStr.length > 0 && scope.currentIndex === -1) {\n              handleOverrideSuggestions();\n            }\n          }\n        }\n      };\n\n      scope.resetHideResults = function() {\n        if (hideTimer) {\n          $timeout.cancel(hideTimer);\n        }\n      };\n\n      scope.hoverRow = function(index) {\n        scope.currentIndex = index;\n      };\n\n      scope.selectResult = function(result) {\n        // Restore original values\n        if (scope.matchClass) {\n          result.title = extractTitle(result.originalObject);\n          result.description = extractValue(result.originalObject, scope.descriptionField);\n        }\n\n        if (scope.clearSelected) {\n          scope.searchStr = null;\n        }\n        else {\n          scope.searchStr = result.title;\n        }\n        callOrAssign(result);\n        clearResults();\n      };\n\n      scope.inputChangeHandler = function(str) {\n        if (str.length < minlength) {\n          cancelHttpRequest();\n          clearResults();\n        }\n        else if (str.length === 0 && minlength === 0) {\n          scope.searching = false;\n          showAll();\n        }\n\n        if (scope.inputChanged) {\n          str = scope.inputChanged(str);\n        }\n        return str;\n      };\n\n      // check required\n      if (scope.fieldRequiredClass && scope.fieldRequiredClass !== '') {\n        requiredClassName = scope.fieldRequiredClass;\n      }\n\n      // check min length\n      if (scope.minlength && scope.minlength !== '') {\n        minlength = parseInt(scope.minlength, 10);\n      }\n\n      // check pause time\n      if (!scope.pause) {\n        scope.pause = PAUSE;\n      }\n\n      // check clearSelected\n      if (!scope.clearSelected) {\n        scope.clearSelected = false;\n      }\n\n      // check override suggestions\n      if (!scope.overrideSuggestions) {\n        scope.overrideSuggestions = false;\n      }\n\n      // check required field\n      if (scope.fieldRequired && ctrl) {\n        // check initial value, if given, set validitity to true\n        if (scope.initialValue) {\n          handleRequired(true);\n        }\n        else {\n          handleRequired(false);\n        }\n      }\n\n      scope.inputType = attrs.type ? attrs.type : 'text';\n\n      // set strings for \"Searching...\" and \"No results\"\n      scope.textSearching = attrs.textSearching ? attrs.textSearching : TEXT_SEARCHING;\n      scope.textNoResults = attrs.textNoResults ? attrs.textNoResults : TEXT_NORESULTS;\n      displaySearching = scope.textSearching === 'false' ? false : true;\n      displayNoResults = scope.textNoResults === 'false' ? false : true;\n\n      // set max length (default to maxlength deault from html\n      scope.maxlength = attrs.maxlength ? attrs.maxlength : MAX_LENGTH;\n\n      // register events\n      inputField.on('keydown', keydownHandler);\n      inputField.on('keyup', keyupHandler);\n\n      // set response formatter\n      responseFormatter = callFunctionOrIdentity('remoteUrlResponseFormatter');\n\n      // set isScrollOn\n      $timeout(function() {\n        var css = getComputedStyle(dd);\n        isScrollOn = css.maxHeight && css.overflowY === 'auto';\n      });\n    }\n\n    return {\n      restrict: 'EA',\n      require: '^?form',\n      scope: {\n        selectedObject: '=',\n        disableInput: '=',\n        initialValue: '=',\n        localData: '=',\n        remoteUrlRequestFormatter: '=',\n        remoteUrlRequestWithCredentials: '@',\n        remoteUrlResponseFormatter: '=',\n        remoteUrlErrorCallback: '=',\n        remoteApiHandler: '=',\n        id: '@',\n        type: '@',\n        placeholder: '@',\n        remoteUrl: '@',\n        remoteUrlDataField: '@',\n        titleField: '@',\n        descriptionField: '@',\n        imageField: '@',\n        inputClass: '@',\n        pause: '@',\n        searchFields: '@',\n        minlength: '@',\n        matchClass: '@',\n        clearSelected: '@',\n        overrideSuggestions: '@',\n        fieldRequired: '=',\n        fieldRequiredClass: '@',\n        inputChanged: '=',\n        autoMatch: '@',\n        focusOut: '&',\n        focusIn: '&',\n        inputName: '@',\n        focusFirst: '@',\n        parseInput: '&'\n      },\n      templateUrl: function(element, attrs) {\n        return attrs.templateUrl || TEMPLATE_URL;\n      },\n      compile: function(tElement) {\n        var startSym = $interpolate.startSymbol();\n        var endSym = $interpolate.endSymbol();\n        if (!(startSym === '{{' && endSym === '}}')) {\n          var interpolatedHtml = tElement.html()\n            .replace(/\\{\\{/g, startSym)\n            .replace(/\\}\\}/g, endSym);\n          tElement.html(interpolatedHtml);\n        }\n        return link;\n      }\n    };\n  }]);\n\n}));\n","var app = angular.module('loydaLahde', ['nemLogging', 'leaflet-directive', 'angucomplete-alt']);\n\napp.config(function ($interpolateProvider) {\n\n    // $interpolateProvider.startSymbol('<%');\n    // $interpolateProvider.endSymbol('%>');\n\n});\n\napp.controller(\"FrontPageMapController\", ['$scope', '$http', function ($scope, $http) {\n\n    $scope.springList = {};\n    //var markerIcon = 'fa-check-circle-o';\n    var markerIcon = 'fa fa-tint';\n    var markerColor = 'green';\n\n    $http.get('/api/springs').then(function (resp) {\n        //console.log('Success', resp);\n        // For JSON responses, resp.data contains the result\n\n        resp.data.forEach(function (item, index) {\n/*\n            switch (item.status) {\n                case 'juomakelpoista':\n                    markerIcon = 'fa-check-circle';\n                    markerColor = 'green';\n                    break;\n                case 'ei tietoa':\n                    markerIcon = 'fa-question-circle';\n                    markerColor = 'orange';\n                    break;\n                case 'ei juomakelpoista':\n                    markerIcon = 'fa-exclamation';\n                    markerColor = 'red';\n                    break;\n            }\n*/\n            $scope.springList[index] = {\n                lat: item.latitude,\n                lng: item.longitude,\n                message: '<h4>' + item.title + '</h4><p><a href=\"/lahteet/' + item.slug +'\">Tarkemmat tiedot</a></p>',\n                focus: false,\n                draggable: false,\n                icon: {\n                    type: 'awesomeMarker',\n                    prefix: 'fa',\n                    icon: markerIcon\n                    //markerColor: markerColor\n                }\n\n            }\n        });\n\n\n    }, function (err) {\n        //console.error('ERR', err);\n        // err.status will contain the status code\n    });\n\n    angular.extend($scope, {\n        finlandCenter: {\n            lat: 64.96,\n            lng: 27.59,\n            zoom: 5\n        },\n        markers: $scope.springList,\n        defaults: {\n            scrollWheelZoom: false\n        }/*,\n        legend: {\n            position: 'bottomleft',\n            colors: ['#D53E2A', '#F49630', '#72AF26'],\n            labels: ['Ei juomakelpoista', 'Ei testattua tietoa', 'Juomakelpoista']\n        }*/\n    });\n}]);\n\napp.controller(\"SingleSpringController\",['$scope', '$http', function($scope, $http){\n    angular.extend($scope, {\n        defaults: {\n            scrollWheelZoom: false\n        }\n    });\n}]);"],"sourceRoot":"/source/"}